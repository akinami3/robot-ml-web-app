"""
Robot AI Web Application - Backend Configuration

Uses pydantic-settings to load configuration from environment variables.

【日本語解説】
このファイルは、アプリケーション全体の「設定（コンフィグ）」を一元管理するファイルです。
データベースの接続先、認証の秘密鍵、サーバーのポート番号など、
アプリが動作するために必要な各種パラメータをここで定義しています。

「環境変数（environment variables）」という仕組みを使って、
開発環境・本番環境ごとに設定値を切り替えられるようになっています。
例えば、開発中はローカルのデータベースを使い、本番では別のサーバーを使う、
といった切り替えが、コードを変更せずに可能です。
"""

# ============================================================
# インポート部分
# ============================================================

# functools.lru_cache:
#   「LRU（Least Recently Used）キャッシュ」を提供するデコレータです。
#   一度呼び出した関数の結果をメモリに保存（キャッシュ）し、
#   同じ引数で再度呼ばれたときは計算し直さずにキャッシュから返します。
#   ここでは、設定オブジェクトを何度も生成しないようにするために使います。
from functools import lru_cache

# pathlib.Path:
#   ファイルパス（ファイルの場所）を扱うためのクラスです。
#   文字列でパスを操作するよりも安全で読みやすいコードが書けます。
#   例: Path("/app/keys/private.pem").exists() → ファイルが存在するか確認
from pathlib import Path

# pydantic_settings.BaseSettings:
#   pydantic-settings ライブラリが提供する基底クラスです。
#   このクラスを継承すると、クラスの属性（フィールド）が自動的に
#   「環境変数」や「.envファイル」から値を読み込めるようになります。
#
#   【環境変数とは？】
#   OSが管理する「名前=値」のペアで、プログラムの外部から設定を渡す仕組みです。
#   ターミナルで `export DATABASE_URL=...` のように設定したり、
#   .env ファイルに書いておくことで、コードを変えずに動作を切り替えられます。
#
#   【pydantic-settings とは？】
#   Pydantic（データ検証ライブラリ）の拡張で、環境変数を型安全に読み込めます。
#   例えば int 型のフィールドに文字列 "8000" が渡されても、自動で整数に変換してくれます。
#   値が不正な場合はエラーを出してくれるので、設定ミスに早く気づけます。
from pydantic_settings import BaseSettings


# ============================================================
# 設定クラス（Settings）
# ============================================================

class Settings(BaseSettings):
    """Application settings loaded from environment variables.

    【日本語解説】
    アプリケーションの全設定を保持するクラスです。
    BaseSettings を継承しているため、各フィールド名と同じ名前の
    環境変数が存在すれば、その値が自動的に読み込まれます。
    環境変数が無い場合は、ここで指定したデフォルト値が使われます。

    例: フィールド名 `backend_port` → 環境変数 `BACKEND_PORT` に対応
        （大文字・小文字は自動変換されます）
    """

    # ----------------------------------------------------------
    # 一般設定（General）
    # ----------------------------------------------------------
    # environment: アプリの動作モード。"development"（開発）や "production"（本番）など。
    #   開発中はデバッグ情報を多く表示し、本番ではセキュリティを重視する、
    #   といった切り替えに使います。
    environment: str = "development"

    # debug: デバッグモードの有効/無効を制御するフラグ。
    #   True にすると、エラー発生時に詳細な情報が表示されます。
    #   本番環境では必ず False にしてください（セキュリティリスクがあるため）。
    debug: bool = False

    # ----------------------------------------------------------
    # サーバー設定（Server）
    # ----------------------------------------------------------
    # backend_host: サーバーがリッスン（待ち受け）するIPアドレス。
    #   "0.0.0.0" は「すべてのネットワークインターフェースで待ち受ける」という意味です。
    #   Docker コンテナ内で動かす場合、外部からアクセスするためにこの設定が必要です。
    backend_host: str = "0.0.0.0"

    # backend_port: サーバーが使うポート番号。
    #   ポート番号は「建物の部屋番号」のようなもので、
    #   同じサーバー上で複数のサービスを区別するために使います。
    #   8000 は Python の Web フレームワーク（FastAPI など）でよく使われる番号です。
    backend_port: int = 8000

    # backend_log_level: ログ（実行記録）の詳細度。
    #   "debug" > "info" > "warning" > "error" の順に情報量が減ります。
    #   "info" は通常の運用に適したレベルです。
    backend_log_level: str = "info"

    # ----------------------------------------------------------
    # データベース設定（Database）
    # ----------------------------------------------------------
    # database_url: データベースへの接続文字列（接続先情報をまとめた文字列）。
    #   形式: "ドライバ://ユーザー名:パスワード@ホスト:ポート/データベース名"
    #   - postgresql+asyncpg: PostgreSQL に非同期（async）で接続するドライバ
    #   - robot_app:password: ユーザー名とパスワード（本番では必ず変更すること！）
    #   - localhost:5432: 接続先ホストとポート（5432 は PostgreSQL のデフォルト）
    #   - robot_ai_db: 使用するデータベースの名前
    database_url: str = "postgresql+asyncpg://robot_app:password@localhost:5432/robot_ai_db"

    # db_pool_size: データベース接続プールのサイズ（同時に保持する接続数）。
    #   毎回接続を作り直すのは遅いので、あらかじめ決まった数の接続を
    #   「プール（ためておく場所）」に保持して使い回します。
    db_pool_size: int = 10

    # db_max_overflow: プールの上限を超えて一時的に作れる追加接続数。
    #   アクセスが集中したとき、プールサイズ + この数まで接続を増やせます。
    db_max_overflow: int = 20

    # ----------------------------------------------------------
    # Redis 設定
    # ----------------------------------------------------------
    # redis_url: Redis サーバーへの接続文字列。
    #   Redis はインメモリ（メモリ上で動く）データストアで、
    #   キャッシュやセッション管理、リアルタイム通信などに使われます。
    #   末尾の "/0" はデータベース番号（Redis は 0〜15 の番号でDBを分けられます）。
    redis_url: str = "redis://localhost:6379/0"

    # ----------------------------------------------------------
    # JWT / 認証設定（JWT / Auth）
    # ----------------------------------------------------------
    # 【JWT（JSON Web Token）とは？】
    #   ユーザーのログイン状態を安全に管理するための仕組みです。
    #   ログイン成功時にサーバーが「トークン（token）」と呼ばれる文字列を発行し、
    #   クライアント（ブラウザ）がそれを毎回のリクエストに添付することで
    #   「この人はログイン済みです」と証明します。

    # secret_key: トークンの署名に使う秘密鍵（文字列版）。
    #   この値が漏れると、誰でも偽のトークンを作れてしまいます。
    #   本番環境では必ずランダムで長い文字列に変更してください！
    secret_key: str = "change-this-in-production"

    # jwt_algorithm: JWT の署名アルゴリズム。
    #   "RS256" は RSA 公開鍵暗号を使った方式で、
    #   秘密鍵で署名し、公開鍵で検証します（より安全）。
    jwt_algorithm: str = "RS256"

    # jwt_access_expire_minutes: アクセストークンの有効期限（分）。
    #   短いほどセキュリティは高まりますが、ユーザーが頻繁に再認証を求められます。
    #   15分は一般的なバランスの良い設定です。
    jwt_access_expire_minutes: int = 15

    # jwt_refresh_expire_days: リフレッシュトークンの有効期限（日）。
    #   アクセストークンが期限切れになったとき、リフレッシュトークンを使って
    #   新しいアクセストークンを取得できます。こちらは長めに設定します。
    jwt_refresh_expire_days: int = 7

    # jwt_private_key_path / jwt_public_key_path:
    #   RS256 アルゴリズムで使う秘密鍵・公開鍵ファイルのパス。
    #   秘密鍵（private key）: トークンに「署名」するために使う（サーバーだけが持つ）
    #   公開鍵（public key）: トークンの署名を「検証」するために使う（共有可能）
    jwt_private_key_path: str = "/app/keys/private.pem"
    jwt_public_key_path: str = "/app/keys/public.pem"

    # ----------------------------------------------------------
    # 管理者設定（Admin）
    # ----------------------------------------------------------
    # admin_email / admin_password:
    #   初期管理者アカウントの情報。アプリ初回起動時にこの情報で
    #   管理者ユーザーが自動作成されます。
    #   ⚠️ 本番環境では必ず安全なパスワードに変更してください！
    admin_email: str = "admin@example.com"
    admin_password: str = "changeme123"

    # ----------------------------------------------------------
    # CORS 設定
    # ----------------------------------------------------------
    # 【CORS（Cross-Origin Resource Sharing）とは？】
    #   ブラウザのセキュリティ機能の一つで、異なるドメイン（オリジン）間の
    #   リクエストを制御します。例えば、フロントエンド（localhost:3000）から
    #   バックエンド（localhost:8000）へのリクエストは「クロスオリジン」となり、
    #   明示的に許可しないとブラウザがブロックします。
    #
    # cors_origins: 許可するオリジン（アクセス元）をカンマ区切りで指定。
    #   ここに記載されたURLからのリクエストだけが許可されます。
    cors_origins: str = "http://localhost:3000,http://localhost:5173"

    # ----------------------------------------------------------
    # レート制限（Rate Limiting）
    # ----------------------------------------------------------
    # rate_limit_per_minute: 1分間あたりの最大リクエスト数。
    #   DDoS攻撃（大量リクエストによる攻撃）やAPIの過剰利用を防ぐために、
    #   一定時間内のリクエスト数を制限します。
    rate_limit_per_minute: int = 60

    # ----------------------------------------------------------
    # Ollama / LLM 設定
    # ----------------------------------------------------------
    # 【Ollama とは？】
    #   ローカル環境で大規模言語モデル（LLM）を実行するためのツールです。
    #   ChatGPT のような AI モデルを自分のサーバー上で動かせます。

    # ollama_url: Ollama サーバーの URL。
    ollama_url: str = "http://localhost:11434"

    # llm_model: 使用する言語モデルの名前。
    #   "llama3" は Meta が開発したオープンソースの大規模言語モデルです。
    llm_model: str = "llama3"

    # embedding_model: テキストをベクトル（数値の配列）に変換するモデル。
    #   RAG（後述）でテキストの類似度を計算するために使われます。
    embedding_model: str = "nomic-embed-text"

    # ----------------------------------------------------------
    # RAG 設定
    # ----------------------------------------------------------
    # 【RAG（Retrieval-Augmented Generation）とは？】
    #   「検索拡張生成」と呼ばれる手法で、LLM に外部の知識を与えて
    #   より正確な回答を生成させる仕組みです。
    #   ドキュメントを小さな「チャンク（断片）」に分割し、
    #   質問に関連するチャンクを検索してLLMに渡します。

    # rag_chunk_size: 1つのチャンクの最大文字数。
    #   大きすぎると検索精度が下がり、小さすぎると文脈が失われます。
    rag_chunk_size: int = 500

    # rag_chunk_overlap: チャンク間の重複文字数。
    #   チャンクの境界で文脈が途切れないよう、隣接するチャンク同士を
    #   少し重ねて分割します。
    rag_chunk_overlap: int = 100

    # rag_top_k: 検索で取得する上位チャンク数。
    #   質問に最も関連性の高いチャンクを何件LLMに渡すかを決めます。
    rag_top_k: int = 5

    # ----------------------------------------------------------
    # Gateway gRPC 設定
    # ----------------------------------------------------------
    # 【gRPC とは？】
    #   Google が開発した高速な通信プロトコル（通信の約束事）です。
    #   マイクロサービス（小さなサービスの集まり）間の通信に適しています。
    #   REST API より高速で、型安全な通信ができます。

    # gateway_grpc_host: gRPC ゲートウェイサーバーのホスト名。
    #   Docker Compose 環境では、サービス名（"gateway"）でアクセスできます。
    gateway_grpc_host: str = "gateway"

    # gateway_grpc_port: gRPC ゲートウェイサーバーのポート番号。
    #   50051 は gRPC でよく使われるデフォルトポートです。
    gateway_grpc_port: int = 50051

    # ----------------------------------------------------------
    # TimescaleDB データ保持期間設定
    # ----------------------------------------------------------
    # 【TimescaleDB とは？】
    #   PostgreSQL の拡張で、時系列データ（センサー値やログなど、
    #   時間とともに増え続けるデータ）を効率的に扱えるようにしたものです。
    #   古いデータを自動的に削除する「リテンション（保持期間）」機能があります。

    # timescaledb_retention_sensor_days: センサーデータの保持日数。
    #   90日を過ぎたセンサーデータは自動的に削除されます。
    timescaledb_retention_sensor_days: int = 90

    # timescaledb_retention_command_days: コマンドデータの保持日数。
    #   コマンド（ロボットへの指示）の履歴は、センサーデータより
    #   長く保持します（監査やデバッグのため）。
    timescaledb_retention_command_days: int = 180

    # ----------------------------------------------------------
    # プロパティ（computed fields / 算出フィールド）
    # ----------------------------------------------------------
    # 【@property とは？】
    #   メソッド（関数）をフィールド（属性）のように呼び出せる仕組みです。
    #   settings.cors_origin_list のように () なしでアクセスできます。
    #   値を「計算して返す」フィールドを定義したいときに使います。

    @property
    def cors_origin_list(self) -> list[str]:
        """CORS のオリジン文字列をリスト（配列）に変換して返す。

        【処理内容】
        カンマ区切りの文字列 "http://localhost:3000,http://localhost:5173" を
        リスト ["http://localhost:3000", "http://localhost:5173"] に変換します。
        strip() は各要素の前後の空白を取り除きます。
        """
        return [origin.strip() for origin in self.cors_origins.split(",")]

    @property
    def jwt_private_key(self) -> str | None:
        """JWT の秘密鍵ファイルを読み込んで文字列として返す。

        【処理内容】
        1. jwt_private_key_path で指定されたパスの Path オブジェクトを作成
        2. ファイルが存在するか確認（exists()）
        3. 存在すればファイルの中身を読み込んで返す（read_text()）
        4. 存在しなければ None を返す

        【str | None とは？】
        戻り値の型ヒントで、「文字列（str）または None のどちらかを返す」
        という意味です。Python 3.10 以降で使える書き方です。
        """
        path = Path(self.jwt_private_key_path)
        if path.exists():
            return path.read_text()
        return None

    @property
    def jwt_public_key(self) -> str | None:
        """JWT の公開鍵ファイルを読み込んで文字列として返す。

        秘密鍵と同様の処理で、公開鍵ファイルを読み込みます。
        公開鍵はトークンの検証（「本物かどうか確認」）に使います。
        """
        path = Path(self.jwt_public_key_path)
        if path.exists():
            return path.read_text()
        return None

    # ----------------------------------------------------------
    # Pydantic モデル設定
    # ----------------------------------------------------------
    # model_config: Pydantic の動作をカスタマイズする設定辞書。
    #   - "env_file": 環境変数を読み込む .env ファイルのパス。
    #     .env ファイルは「KEY=VALUE」形式で環境変数を定義するテキストファイルです。
    #     コードに直接値を書かずに、設定を外部ファイルで管理できます。
    #   - "env_file_encoding": .env ファイルの文字エンコーディング（通常は UTF-8）。
    model_config = {"env_file": ".env", "env_file_encoding": "utf-8"}


# ============================================================
# 設定オブジェクトの取得関数
# ============================================================

# @lru_cache デコレータの解説:
#   この関数の戻り値をキャッシュ（記憶）します。
#   初回呼び出し時に Settings() が作成され、2回目以降は
#   キャッシュされた同じオブジェクトが返されます。
#
#   【なぜキャッシュするのか？】
#   Settings の生成には .env ファイルの読み込みや環境変数の解析が必要です。
#   アプリ内の様々な場所で設定を参照するたびに毎回この処理をするのは無駄なので、
#   一度だけ生成してキャッシュすることで効率化しています。
#   これは「シングルトンパターン」に近い考え方です。
@lru_cache
def get_settings() -> Settings:
    """Settings オブジェクトを取得する（キャッシュ付き）。

    【使い方の例】
    from app.config import get_settings
    settings = get_settings()
    print(settings.backend_port)  # → 8000
    """
    return Settings()
