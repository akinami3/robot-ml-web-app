"""
=============================================================================
セキュリティモジュールのテスト（test_security.py）
=============================================================================

【パスワードハッシュ化とは？】
パスワードを不可逆な文字列に変換する処理です。

  平文:     "my_password"
  ハッシュ: "$2b$12$LJ3m4ys3Lk..."（元に戻せない！）

【なぜハッシュ化が必要？】
データベースが侵害された場合でも、ユーザーのパスワードが漏洩しません。
ハッシュ化されたパスワードから元のパスワードを復元することは
（実用的な時間内では）不可能です。

【bcrypt（ビークリプト）とは？】
パスワードハッシュ化に特化したアルゴリズムです:
  1. ソルト（salt）: ランダムな値を追加してハッシュを計算
     → 同じパスワードでも毎回異なるハッシュ値になる
     → レインボーテーブル攻撃（事前計算した対照表）を防止
  2. ストレッチング: 計算を意図的に遅くする（ブルートフォース攻撃を困難に）
  3. コストファクター: 計算の遅さを調整可能

【テストの観点】
  1. 正しいパスワードで検証が成功すること
  2. 間違ったパスワードで検証が失敗すること
  3. 同じパスワードでも毎回異なるハッシュが生成されること（ソルトの検証）
=============================================================================
"""

from __future__ import annotations

# テスト対象の関数をインポート
# hash_password:  パスワード → ハッシュ値に変換
# verify_password: パスワードとハッシュ値を比較して一致するか確認
from app.core.security import hash_password, verify_password


class TestPasswordHashing:
    """
    パスワードハッシュ化と検証のテスト。

    【テストクラスの使い方】
    関連するテストをクラスでグループ化します。
    pytestではクラス名が "Test" で始まるとテストクラスとして認識されます。
    メソッド名が "test_" で始まるとテストメソッドとして認識されます。

    【テストの3パターン】
      1. 正常系（Happy Path）: 正しい入力で正しい結果が得られる
      2. 異常系（Error Path）: 間違った入力で適切にエラーになる
      3. エッジケース: 境界的な条件でも正しく動作する
    """

    def test_hash_and_verify(self):
        """
        正しいパスワードでハッシュ化と検証が成功することをテスト。

        【正常系テスト（Happy Path）】
        最も基本的なテスト: パスワードをハッシュ化し、同じパスワードで検証して
        True が返ることを確認します。

        処理の流れ:
          1. "my_secure_password" → hash_password() → "$2b$12$abc..."
          2. verify_password("my_secure_password", "$2b$12$abc...") → True

        verify_password の内部動作:
          - 入力パスワードをハッシュ値に含まれるソルトで再ハッシュ
          - 再ハッシュした結果と保存済みハッシュを比較
          - 一致すれば True
        """
        password = "my_secure_password"
        hashed = hash_password(password)
        assert verify_password(password, hashed)

    def test_wrong_password_fails(self):
        """
        間違ったパスワードで検証が失敗することをテスト。

        【異常系テスト（Negative Test）】
        間違ったパスワードが通ってしまうと、誰でもログインできてしまう！
        セキュリティ上、このテストは正常系と同等以上に重要です。

        「正しいパスワードで成功する」だけでなく、
        「間違ったパスワードで確実に失敗する」ことの検証が不可欠です。
        """
        hashed = hash_password("correct")
        # "wrong" はハッシュ化に使ったパスワードと異なるため False になるべき
        assert not verify_password("wrong", hashed)

    def test_hash_is_different_each_time(self):
        """
        同じパスワードでも毎回異なるハッシュ値が生成されることをテスト。

        【bcrypt のソルト（salt）の検証】
        ソルト = ハッシュ計算時に追加されるランダムな値
        ソルトがあるため、同じパスワードでも毎回異なるハッシュが生成されます。

        なぜこれが重要？
        ソルトがない場合:
          "password123" → 常に同じハッシュ "abc..."
          → 攻撃者はよく使われるパスワードのハッシュ一覧表（レインボーテーブル）を
            事前に作成して、一致するものを探すだけで解読できてしまう

        ソルトがある場合:
          "password123" + ソルト1 → "xyz..."
          "password123" + ソルト2 → "def..."
          → 毎回異なるため、レインボーテーブル攻撃が無効化される

        【テストの構造】
          1. 同じパスワードで2回ハッシュ化
          2. h1 != h2 であることを確認（ソルトが異なるため）
          3. 両方とも verify_password で True になることを確認
             （ハッシュは異なるが、どちらも正しいパスワードで検証できる）
        """
        password = "same_password"
        h1 = hash_password(password)
        h2 = hash_password(password)

        # 【ソルトの検証】同じパスワードでもハッシュ値は異なる
        assert h1 != h2  # bcrypt uses random salt

        # 【どちらのハッシュでも検証は成功する】
        # ハッシュ値は異なるが、元のパスワードは同じなので両方 True
        assert verify_password(password, h1)
        assert verify_password(password, h2)
