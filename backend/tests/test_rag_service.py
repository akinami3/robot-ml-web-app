# =============================================================================
# RAG サービスのユニットテスト
# =============================================================================
#
# 【このファイルの役割】
# RAG（Retrieval-Augmented Generation）サービスの中核機能である
# 「テキスト分割（Text Splitting / Chunking）」のテストを行います。
#
# 【RAG とは？】
# RAG は「検索拡張生成」と訳される AI 技術です。
# LLM（大規模言語モデル、例：ChatGPT）に質問する際、
# 関連するドキュメントを検索して一緒に渡すことで、
# より正確な回答を生成させる手法です。
#
# 流れ：
#   1. ユーザーが質問する（例：「ロボットのバッテリー交換方法は？」）
#   2. ドキュメントデータベースから関連する文章を検索する
#   3. 検索結果 + 質問を LLM に渡す
#   4. LLM がドキュメントを参考にして回答を生成する
#
# 【なぜテキスト分割（チャンキング）が必要なのか？】
# LLM には「コンテキストウィンドウ」というトークン数の上限があります。
# （例：GPT-4 は約 128,000 トークン、Claude は約 200,000 トークン）
#
# 長いドキュメント（例：100 ページの PDF マニュアル）をそのまま LLM に
# 渡すことはできません。そこで：
#   1. ドキュメントを小さな「チャンク（塊）」に分割する
#   2. 各チャンクをベクトル化（数値の配列に変換）してデータベースに保存
#   3. 質問に関連するチャンクだけを検索して LLM に渡す
# これにより、トークン上限を超えずに大量のドキュメントを活用できます。
#
# 【チャンクのオーバーラップ（重複）とは？】
# テキストを単純に分割すると、分割境界で文脈が切れてしまいます。
# 例：「ロボットのバッテリーは |（ここで分割）| 8時間持続します」
#
# オーバーラップ＝分割時に前後のチャンクで一部の文章を重複させること。
# これにより、分割境界付近の情報も検索でヒットしやすくなります。
#
# 例（chunk_size=100, overlap=20 の場合）：
#   チャンク1: 文字 0〜99
#   チャンク2: 文字 80〜179  ← 文字 80〜99 がチャンク1と重複
#   チャンク3: 文字 160〜259 ← 文字 160〜179 がチャンク2と重複
#
# 【テストの実行方法】
# プロジェクトルートで以下のコマンドを実行：
#   pytest backend/tests/test_rag_service.py -v
#
# -v オプションで各テストケースの結果が詳細に表示されます。
# =============================================================================

# ---------------------------------------------------------------------------
# from __future__ import annotations
# ---------------------------------------------------------------------------
# Python の型ヒント（型注釈）を新しいスタイルで書けるようにするインポート。
# Python 3.12 では必須ではありませんが、慣習的に書かれることが多いです。
# 例：list[str] と書けるようになる（従来は List[str] と書く必要があった）
# ---------------------------------------------------------------------------
"""RAG service unit tests."""

from __future__ import annotations

# ---------------------------------------------------------------------------
# テスト対象のインポート
# ---------------------------------------------------------------------------
# app.domain.services.rag_service モジュールから TextSplitter クラスを読み込み。
# TextSplitter はテキストをチャンク（塊）に分割するクラスです。
#
# 引数：
#   chunk_size: 1 つのチャンクの最大文字数
#   overlap:    チャンク間で重複させる文字数
# ---------------------------------------------------------------------------
from app.domain.services.rag_service import TextSplitter


# =============================================================================
# TestTextSplitter テストクラス
# =============================================================================
# pytest では、Test で始まるクラス名のクラスが自動的にテストクラスとして認識。
# 各メソッド（test_ で始まるもの）が個別のテストケースとして実行されます。
#
# 【テスト設計の考え方】
# 良いテストは以下のケースをカバーします：
#   - 正常系（期待通りの入力）
#   - 境界値（ちょうどチャンクサイズと同じ長さ、など）
#   - 異常系（空文字列、極端に長い文字列、など）
#   - エッジケース（オーバーラップによる重複の確認、など）
# =============================================================================
class TestTextSplitter:

    # -------------------------------------------------------------------------
    # テスト 1: 短いテキストは分割されないことを確認
    # -------------------------------------------------------------------------
    # chunk_size=100 に対して "Hello world"（11 文字）を分割すると、
    # チャンクサイズ以下なので分割する必要がなく、1 つのチャンクになるはず。
    #
    # assert 文（アサーション）：
    #   assert 条件式   → 条件が True なら OK、False ならテスト失敗
    #   len(chunks)     → チャンクの数を取得する（len = length = 長さ）
    # -------------------------------------------------------------------------
    def test_short_text_no_split(self):
        # TextSplitter を作成（チャンクサイズ 100 文字、オーバーラップ 10 文字）
        splitter = TextSplitter(chunk_size=100, overlap=10)
        # "Hello world" を分割
        chunks = splitter.split("Hello world")
        # チャンク数が 1 であることを確認（分割されていない）
        assert len(chunks) == 1
        # チャンクの内容が元のテキストと完全に一致することを確認
        assert chunks[0] == "Hello world"

    # -------------------------------------------------------------------------
    # テスト 2: 長いテキストが正しく分割されることを確認
    # -------------------------------------------------------------------------
    # chunk_size=50 に対して "A" * 200（200 文字の A の繰り返し）を分割すると、
    # 複数のチャンクに分割されるはず。
    #
    # "A" * 200 は "AAAA...A"（A が 200 個）という文字列を生成します。
    # Python の文字列の掛け算は、文字列を繰り返す操作です。
    # -------------------------------------------------------------------------
    def test_long_text_splits(self):
        splitter = TextSplitter(chunk_size=50, overlap=10)
        text = "A" * 200  # 200 文字の "AAA...A" を生成
        chunks = splitter.split(text)
        # チャンク数が 2 以上であることを確認（分割が行われた）
        assert len(chunks) > 1

    # -------------------------------------------------------------------------
    # テスト 3: 段落境界（改行）での分割を確認
    # -------------------------------------------------------------------------
    # テキスト分割器は、可能であれば単語の途中ではなく、
    # 段落の切れ目（\n\n = 空行）で分割する方が望ましいです。
    # これにより、意味的にまとまった文章がチャンク内に収まります。
    #
    # "\n\n" は「空行」を表し、段落の区切りとしてよく使われます。
    # -------------------------------------------------------------------------
    def test_splits_at_paragraph_boundary(self):
        splitter = TextSplitter(chunk_size=100, overlap=10)
        text = "First paragraph.\n\nSecond paragraph.\n\nThird paragraph that is a bit longer to ensure splitting."
        chunks = splitter.split(text)
        # 少なくとも 1 つのチャンクが生成されることを確認
        assert len(chunks) >= 1

    # -------------------------------------------------------------------------
    # テスト 4: 空文字列を渡した場合の動作を確認
    # -------------------------------------------------------------------------
    # エッジケース（特殊なケース）のテストです。
    # 空文字列 "" を渡した場合、空のリスト [] または
    # 1 つの空チャンク [""] が返されることを確認します。
    #
    # プログラムが空入力で例外（エラー）を出さないことを保証するために重要。
    # -------------------------------------------------------------------------
    def test_empty_text(self):
        splitter = TextSplitter(chunk_size=100, overlap=10)
        chunks = splitter.split("")
        # チャンク数が 0 または 1 であることを確認
        assert len(chunks) <= 1

    # -------------------------------------------------------------------------
    # テスト 5: オーバーラップによる重複が正しく機能するか確認
    # -------------------------------------------------------------------------
    # chunk_size=20, overlap=5 で複数の単語からなるテキストを分割。
    # オーバーラップが有効な場合、隣接するチャンクに共通する部分が存在するはず。
    #
    # 【なぜオーバーラップが重要なのか？】
    # 文脈が途切れるのを防ぎ、検索精度を向上させるためです。
    # 例えば「ロボットのバッテリーは8時間」という文が分割境界にある場合、
    # オーバーラップなし → 「ロボットのバッテリーは」「8時間持続」で情報が分断
    # オーバーラップあり → 両方のチャンクに完全な文が含まれる
    # -------------------------------------------------------------------------
    def test_overlap_creates_redundancy(self):
        splitter = TextSplitter(chunk_size=20, overlap=5)
        text = "word1 word2 word3 word4 word5 word6 word7 word8"
        chunks = splitter.split(text)
        # With overlap, some content should appear in multiple chunks
        # オーバーラップにより、一部の内容が複数のチャンクに含まれるはず
        assert len(chunks) >= 2
