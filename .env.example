# =============================================================================
# Robot AI Web Application - Environment Variables
# ロボットAI Webアプリケーション - 環境変数設定ファイル
# =============================================================================
#
# 【このファイルの役割】
# アプリケーションの設定値を環境変数として定義するテンプレートファイルです。
# .env.example はGitにコミットされる「お手本」で、実際の値は .env に書きます。
#
# 【使い方】
# 1. このファイルをコピーして .env を作成:
#    cp .env.example .env
# 2. .env ファイルの値を自分の環境に合わせて編集
# 3. ⚠️ .env ファイルは .gitignore に追加して、Gitにコミットしないこと！
#    （パスワードなどの秘密情報が含まれるため）
#
# 【環境変数とは？】
# プログラムの外部から設定値を渡す仕組みです。
# コードを変更せずに、異なる環境（開発/本番）で異なる設定を使えます。
# セキュリティ上、パスワードやAPIキーはコードに直接書かず、環境変数で管理します。
#
# 【.env ファイルの仕組み】
# Docker Compose は .env ファイルを自動的に読み込みます。
# docker-compose.yml 内の ${変数名} が .env の値に置き換えられます。
#
# Copy this file to .env and update values as needed
# cp .env.example .env

# -----------------------------------------------------------------------------
# General（全般設定）
# -----------------------------------------------------------------------------
# 【COMPOSE_PROJECT_NAME】
# Docker Composeプロジェクトの名前です。
# コンテナ名のプレフィックスとして使われます。
# 例: robot-ai-webapp-backend-1, robot-ai-webapp-postgres-1
# 複数のプロジェクトを同じマシンで動かす場合に名前の衝突を避けます。
COMPOSE_PROJECT_NAME=robot-ai-webapp

# 【ENVIRONMENT】
# アプリケーションの実行環境を指定します。
# development: 開発環境（デバッグログ有効、詳細なエラー表示）
# production: 本番環境（パフォーマンス重視、最小限のログ）
# staging: ステージング環境（本番に近いテスト環境）
# test: テスト環境（自動テスト実行用）
ENVIRONMENT=development

# -----------------------------------------------------------------------------
# Frontend（フロントエンド設定）
# -----------------------------------------------------------------------------
# 【FRONTEND_PORT】
# フロントエンドのWebサーバーが使うポート番号です。
# ブラウザで http://localhost:3000 にアクセスするとフロントエンドが表示されます。
# ポートとは: ネットワーク上でアプリケーションを識別する番号（0〜65535）
# よく使われるポート: 80（HTTP）、443（HTTPS）、3000（React開発）、5173（Vite開発）
FRONTEND_PORT=3000

# 【VITE_API_BASE_URL】
# フロントエンドからバックエンドAPIを呼ぶときのベースURL。
# /api/v1: APIのバージョン管理（将来 /api/v2 に変更しても旧版を維持できる）
VITE_API_BASE_URL=http://localhost:8000/api/v1

# 【VITE_WS_URL】
# WebSocket接続先のURL。
# ws:// はWebSocketプロトコル（暗号化なし）。
# 本番環境では wss://（暗号化あり）を使用してください。
# /ws: WebSocket用のエンドポイント
VITE_WS_URL=ws://localhost:8080/ws

# -----------------------------------------------------------------------------
# Backend (FastAPI) - バックエンド設定
# -----------------------------------------------------------------------------
# 【BACKEND_PORT】
# バックエンドAPIサーバーのポート番号。
# 開発環境では直接アクセスしますが、本番ではリバースプロキシ経由が一般的です。
BACKEND_PORT=8000

# 【BACKEND_HOST】
# サーバーがリッスンするIPアドレス。
# 0.0.0.0: 全てのネットワークインターフェースでリッスン（コンテナ内で必須）
# 127.0.0.1: ローカルホストのみ（コンテナ外からアクセス不可）
BACKEND_HOST=0.0.0.0

# 【BACKEND_WORKERS】
# gunicorn のワーカープロセス数。
# 推奨値: CPUコア数 × 2 + 1
# 開発環境: 1（ホットリロードとの相性のため）
# 本番環境: 4〜8（CPUコア数に応じて調整）
BACKEND_WORKERS=1

# 【BACKEND_LOG_LEVEL】
# ログの詳細度。低い方が詳細、高い方が重要なもののみ。
# debug → info → warning → error → critical
# 開発環境: debug（全てのログを表示してデバッグに活用）
# 本番環境: info または warning（不要なログを減らしてパフォーマンスを確保）
BACKEND_LOG_LEVEL=debug

# 【SECRET_KEY】
# アプリケーション全体で使用する秘密鍵。
# セッション暗号化、CSRF保護などに使用されます。
# ⚠️ 本番環境では必ずランダムな長い文字列に変更してください！
# 生成方法: python -c "import secrets; print(secrets.token_urlsafe(64))"
SECRET_KEY=change-this-to-a-secure-random-string-in-production

# 【JWT（JSON Web Token）設定】
# JWTは、ユーザー認証（ログイン）に使用するトークンです。
# ログイン時にサーバーがトークンを発行し、以降のリクエストに添付して認証します。
#
# JWT_ALGORITHM: 署名に使うアルゴリズム
# RS256: RSA公開鍵暗号方式
#   → 秘密鍵で署名（バックエンド）、公開鍵で検証（バックエンド + ゲートウェイ）
# HS256: 共有秘密鍵方式（シンプルだが全サービスが秘密鍵を持つ必要がある）
JWT_ALGORITHM=RS256

# JWT_ACCESS_TOKEN_EXPIRE_MINUTES: アクセストークンの有効期限（分）
# 短い方がセキュア（盗まれても短時間で無効になる）
# 長い方がユーザーにとって便利（頻繁にログインし直す必要がない）
# 15分が一般的なバランス。
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=15

# JWT_REFRESH_TOKEN_EXPIRE_DAYS: リフレッシュトークンの有効期限（日）
# アクセストークンが切れたとき、リフレッシュトークンで新しいアクセストークンを取得。
# 7日間有効 = 1週間ログインなしでもセッションを維持。
JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

# 【RSA鍵の生成方法】
# RS256アルゴリズムには公開鍵と秘密鍵のペアが必要です。
# 以下のコマンドで生成できます:
#   openssl genrsa -out private.pem 2048       ← 秘密鍵の生成（2048ビット）
#   openssl rsa -in private.pem -pubout -out public.pem  ← 公開鍵の生成
#
# RSA Keys for JWT (generate with: openssl genrsa -out private.pem 2048 && openssl rsa -in private.pem -pubout -out public.pem)
JWT_PRIVATE_KEY_PATH=/app/keys/private.pem
JWT_PUBLIC_KEY_PATH=/app/keys/public.pem

# 【管理者アカウント】
# 初回起動時に自動作成される管理者ユーザーです。
# ⚠️ 本番環境では必ず強力なパスワードに変更してください！
# パスワードの推奨: 12文字以上、大文字・小文字・数字・記号を含む
#
# First admin user (created on initial startup)
ADMIN_EMAIL=admin@example.com
ADMIN_PASSWORD=changeme123

# -----------------------------------------------------------------------------
# Gateway (Go) - ゲートウェイ設定
# -----------------------------------------------------------------------------
# 【GATEWAY_PORT】
# WebSocket通信用のポート。
# ブラウザからのリアルタイム通信（ロボット操作、ステータス更新）に使用。
GATEWAY_PORT=8080

# 【GATEWAY_GRPC_PORT】
# gRPC通信用のポート。
# バックエンドとゲートウェイ間の内部通信に使用。
# gRPC: Googleが開発した高速なRPC（Remote Procedure Call）フレームワーク。
# Protocol Buffers でデータをシリアライズするため、JSONより高速。
GATEWAY_GRPC_PORT=50051
GATEWAY_LOG_LEVEL=debug

# 【ロボット安全パラメータ】
# ロボットの安全な操作を保証するための制限値です。
# これらの値は、使用するロボットのスペックに合わせて調整してください。

# Safety Parameters
# GATEWAY_ESTOP_ENABLED: 緊急停止（Emergency Stop）機能の有効/無効
# 本番環境では必ず true にしてください！ロボットの暴走を防ぎます。
GATEWAY_ESTOP_ENABLED=true

# GATEWAY_CMD_TIMEOUT_SEC: コマンドのタイムアウト（秒）
# コマンドが3秒以内に完了しない場合、安全のためロボットを停止します。
# → 通信障害時にロボットが制御不能になるのを防ぎます。
GATEWAY_CMD_TIMEOUT_SEC=3

# GATEWAY_MAX_LINEAR_VEL: 最大直進速度（m/s）
# 1.0 m/s = 時速3.6km（人が歩く速度程度）
# ⚠️ 室内で使う場合は 0.5 以下を推奨
GATEWAY_MAX_LINEAR_VEL=1.0

# GATEWAY_MAX_ANGULAR_VEL: 最大回転速度（rad/s）
# 2.0 rad/s ≈ 約115度/秒
GATEWAY_MAX_ANGULAR_VEL=2.0

# GATEWAY_OPERATION_LOCK_TIMEOUT_SEC: 操作ロックのタイムアウト（秒）
# 一人がロボットを操作中は他のユーザーが操作できないように排他制御します。
# 300秒（5分）操作がない場合、自動的にロックが解除されます。
GATEWAY_OPERATION_LOCK_TIMEOUT_SEC=300

# -----------------------------------------------------------------------------
# PostgreSQL (TimescaleDB + pgvector) - データベース設定
# -----------------------------------------------------------------------------
# 【PostgreSQLの接続情報】
# これらの値は docker-compose.yml 内の postgres サービスと一致させてください。
POSTGRES_HOST=postgres
POSTGRES_PORT=5432
POSTGRES_USER=robot_app
# ⚠️ 本番環境では強力なパスワードに変更！
# 生成方法: openssl rand -base64 32
POSTGRES_PASSWORD=robot_app_password_change_me
POSTGRES_DB=robot_ai_db

# 【TimescaleDB設定】
# TimescaleDB はセンサーデータなどの時系列データを効率的に管理する拡張機能です。

# TimescaleDB settings
# TIMESCALEDB_CHUNK_INTERVAL: データを分割する時間間隔
# 1h = 1時間ごとにチャンク（データのまとまり）を作成
# → 古いデータの削除や圧縮を効率的に行えます
TIMESCALEDB_CHUNK_INTERVAL=1h

# TIMESCALEDB_COMPRESSION_AFTER: この期間が過ぎたデータを自動圧縮
# 7d = 7日前のデータを圧縮（ストレージ使用量を90%以上削減可能）
TIMESCALEDB_COMPRESSION_AFTER=7d

# TIMESCALEDB_RETENTION_*_DAYS: データ保持期間
# この期間を超えたデータは自動的に削除されます
# センサーデータ: 90日（頻度が高いため短め）
# コマンド履歴: 180日（履歴として長めに保持）
TIMESCALEDB_RETENTION_SENSOR_DAYS=90
TIMESCALEDB_RETENTION_COMMAND_DAYS=180

# 【DATABASE_URL - データベース接続文字列】
# アプリケーションがデータベースに接続するための統一的なURL形式です。
# 形式: ドライバー://ユーザー:パスワード@ホスト:ポート/データベース名
#
# postgresql+asyncpg:
#   postgresql → データベースの種類
#   asyncpg → 非同期ドライバー（同時に複数のクエリを処理できる）
#
# 注意: ${変数名} は .env ファイル内では展開されません。
# Docker Compose が docker-compose.yml 内で展開する際に使われます。
#
# Database URL (constructed from above)
DATABASE_URL=postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}

# -----------------------------------------------------------------------------
# Redis - キャッシュ・メッセージブローカー設定
# -----------------------------------------------------------------------------
REDIS_HOST=redis
REDIS_PORT=6379
# ⚠️ 本番環境ではパスワードを変更してください！
REDIS_PASSWORD=redis_password_change_me
# Redis接続文字列（上記の変数から構成）
REDIS_URL=redis://:${REDIS_PASSWORD}@${REDIS_HOST}:${REDIS_PORT}/0

# -----------------------------------------------------------------------------
# Ollama (Local LLM) - ローカルAI設定
# -----------------------------------------------------------------------------
OLLAMA_HOST=ollama
OLLAMA_PORT=11434
OLLAMA_BASE_URL=http://${OLLAMA_HOST}:${OLLAMA_PORT}

# 【OLLAMA_MODEL - 使用するLLMモデル】
# llama3: Meta社のLLama 3（オープンソースLLM）
# 他の選択肢: mistral, codellama, gemma など
# モデルの追加: docker exec -it <コンテナ名> ollama pull <モデル名>
OLLAMA_MODEL=llama3

# 【OLLAMA_EMBEDDING_MODEL - 埋め込みモデル】
# テキストをベクトル（数値の配列）に変換するモデルです。
# RAG（Retrieval-Augmented Generation）で類似文書の検索に使用します。
# nomic-embed-text: 軽量で高精度な埋め込みモデル
OLLAMA_EMBEDDING_MODEL=nomic-embed-text

# 【RAG（Retrieval-Augmented Generation）設定】
# RAGとは: AIが回答する際に、関連するドキュメントを検索して参照する技術です。
# AIの「幻覚」（もっともらしいが間違った回答）を減らすのに効果的です。
#
# 処理の流れ:
# 1. ドキュメントを小さなチャンクに分割
# 2. 各チャンクをベクトルに変換してデータベースに保存
# 3. ユーザーの質問もベクトルに変換
# 4. 類似度の高いチャンクを検索（TOP_K件）
# 5. 検索結果とともにAIに質問を投げる

# RAG settings
# RAG_CHUNK_SIZE: 1チャンクの文字数
# 大きすぎる → 関係ない情報が含まれ精度低下
# 小さすぎる → 文脈が失われ、意味のある回答ができない
# 500文字が一般的な開始点
RAG_CHUNK_SIZE=500

# RAG_CHUNK_OVERLAP: チャンク間の重複文字数
# 文の途中で分割されるのを防ぐため、隣接するチャンクに重複部分を持たせる
# CHUNK_SIZEの20%程度が目安（500 × 0.2 = 100）
RAG_CHUNK_OVERLAP=100

# RAG_TOP_K: 検索結果の上位何件をAIに渡すか
# 多いほど網羅的だが、トークン数（＝コスト・処理時間）が増える
# 3〜10が一般的
RAG_TOP_K=5

# -----------------------------------------------------------------------------
# Security（セキュリティ設定）
# -----------------------------------------------------------------------------
# 【CORS_ORIGINS - CORSの許可リスト】
# CORS（Cross-Origin Resource Sharing）: 異なるオリジンからのリクエストを制御
#
# オリジンとは: プロトコル + ホスト + ポート の組み合わせ
# 例: http://localhost:3000 と http://localhost:8000 は異なるオリジン
#
# ブラウザはセキュリティのため、異なるオリジンへのリクエストをデフォルトでブロックします。
# CORS_ORIGINS にフロントエンドのURLを指定することで、APIへのアクセスを許可します。
#
# 開発環境: localhost:3000（本番ポート）と localhost:5173（Vite開発ポート）
# 本番環境: 実際のドメイン名に変更してください（例: https://robot-ai.example.com）
CORS_ORIGINS=http://localhost:3000,http://localhost:5173

# 【RATE_LIMIT_PER_MINUTE - レート制限】
# 1分あたりの最大リクエスト数（APIごと、ユーザーごと）。
# DDoS攻撃（大量のリクエストでサーバーを麻痺させる攻撃）の対策です。
# 60 = 1秒に1リクエスト程度。
# 正常なユーザーには十分な値ですが、攻撃者を抑制します。
RATE_LIMIT_PER_MINUTE=60

# -----------------------------------------------------------------------------
# Backup（バックアップ設定）
# -----------------------------------------------------------------------------
# 【バックアップの重要性】
# データベースやアップロードファイルの定期バックアップは
# 本番環境の運用において最も重要な作業の一つです。
# ハードウェア故障、人為的ミス、セキュリティインシデントからデータを保護します。

# BACKUP_DIR: バックアップファイルの保存先ディレクトリ
BACKUP_DIR=/backups

# BACKUP_RETENTION_DAYS: バックアップファイルの保持日数
# 30日 = 約1ヶ月分のバックアップを保持
# 古いバックアップは自動的に削除されます（ディスク容量の節約）
BACKUP_RETENTION_DAYS=30
