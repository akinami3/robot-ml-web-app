# =============================================================================
# Gateway - Production Dockerfile (Multi-stage)
# ゲートウェイサービスの本番用Dockerイメージを構築する設定ファイル
# =============================================================================
#
# 【Dockerとは？】
# アプリケーションを「コンテナ」という軽量な仮想環境にパッケージングする技術。
# コンテナには、アプリの実行に必要なすべてのもの（コード、ライブラリ、設定）が
# 含まれるため、どの環境でも同じように動作する。
# 「自分のPCでは動くのに、サーバーでは動かない」という問題を解決する。
#
# 【Dockerfileとは？】
# Dockerイメージ（コンテナの設計図）を作成するための手順書。
# 上から順番に命令が実行され、最終的なイメージが作られる。
#
# 【マルチステージビルドとは？】
# Dockerfile内で複数の「ステージ」を使ってイメージを構築する手法。
# このファイルでは2つのステージを使っている:
#   1. builder ステージ: Go のコードをコンパイルする（ビルド環境）
#   2. runtime ステージ: コンパイル済みバイナリだけを含む（実行環境）
#
# 【なぜマルチステージビルドを使うのか？】
# ビルドに必要なツール（Goコンパイラ、git等）は実行時には不要。
# マルチステージビルドにより、最終イメージからビルドツールを除外し、
# イメージサイズを大幅に削減できる（数百MB → 数十MB）。
# これにより、デプロイが高速になり、セキュリティリスクも減少する。
# =============================================================================

# =============================================================================
# ステージ1: ビルドステージ（builder）
# =============================================================================
#
# FROM: ベースイメージを指定する命令
# golang:1.22-alpine: Go 1.22 がインストールされた Alpine Linux ベースのイメージ
#
# 【Alpine Linux とは？】
# 非常に軽量（約5MB）な Linux ディストリビューション。
# 通常の Ubuntu ベースイメージが数百MBなのに対し、Alpine は最小限のサイズ。
# Docker イメージを小さくするためによく使われる。
#
# 【AS builder とは？】
# このステージに "builder" という名前を付けている。
# 後のステージからこの名前で参照でき、ビルド成果物をコピーできる。
FROM golang:1.22-alpine AS builder

# WORKDIR: 作業ディレクトリを設定する命令
# 以降のコマンドはこのディレクトリ内で実行される。
# ディレクトリが存在しない場合は自動的に作成される。
# Linux のコマンド「cd /build」と「mkdir -p /build」を合わせたようなもの。
WORKDIR /build

# =============================================================================
# 依存ツールのインストール
# =============================================================================
#
# RUN: コンテナ内でコマンドを実行する命令
#
# apk: Alpine Linux のパッケージマネージャー
#   （Ubuntu の apt、CentOS の yum に相当する）
# --no-cache: パッケージインデックスのキャッシュを保存しない
#   → イメージサイズを小さくするためのベストプラクティス
#
# git: バージョン管理ツール。Go モジュールのダウンロードに使う場合がある
# ca-certificates: SSL/TLS証明書。HTTPS通信に必要
#   → 外部サービスとの安全な通信を可能にする
RUN apk add --no-cache git ca-certificates

# =============================================================================
# 依存関係のインストール（レイヤーキャッシュの活用）
# =============================================================================
#
# COPY: ホストマシン（自分のPC）からコンテナ内にファイルをコピーする命令
# 書式: COPY <ホスト側のパス> <コンテナ内のパス>
#
# 【なぜ go.mod と go.sum を先にコピーするのか？（レイヤーキャッシュ）】
# Docker はイメージを「レイヤー」という層で構築する。
# 各命令（FROM, COPY, RUN など）が1つのレイヤーになる。
# ファイルが変更されていないレイヤーはキャッシュが使われ、再実行されない。
#
# go.mod（依存関係の定義）は頻繁に変わらないが、ソースコードはよく変わる。
# 依存関係ファイルを先にコピーしてダウンロードすれば、
# ソースコード変更時に依存関係の再ダウンロードを省略できる。
# これにより、ビルド時間を大幅に短縮できる！
#
# 【go.mod と go.sum とは？】
# go.mod: プロジェクトが使う外部ライブラリ（依存関係）の一覧
# go.sum: 各ライブラリのハッシュ値（改ざん検知用のチェックサム）
COPY go.mod go.sum ./

# go mod download: go.mod に記載された依存ライブラリをダウンロードする
RUN go mod download

# ソースコード全体をコピーする
# 「.」はカレントディレクトリ（ホスト側の Dockerfile があるディレクトリ全体）
COPY . .

# =============================================================================
# Go バイナリのビルド
# =============================================================================
#
# 【このビルドコマンドの詳細解説】
#
# CGO_ENABLED=0:
#   CGO（C言語コードとの連携機能）を無効にする。
#   これにより、C言語のライブラリに依存しない「静的リンクバイナリ」が作られる。
#   静的リンクバイナリは、glibcなどのシステムライブラリが不要なため、
#   最小限のコンテナ（distroless）でも動作する。
#
# GOOS=linux:
#   Linux 用のバイナリを生成する（クロスコンパイル設定）。
#   Mac や Windows でビルドしても、Linux で動くバイナリが作られる。
#
# go build:
#   Go のソースコードをコンパイルして実行可能なバイナリを生成する。
#
# -ldflags="-w -s":
#   リンカー（linker）フラグの設定。
#   -w: DWARF デバッグ情報を除外する（デバッグ用データを削除）
#   -s: シンボルテーブルを除外する（関数名などの情報を削除）
#   これにより、バイナリサイズが約30%小さくなる。
#   本番環境ではデバッグ情報は不要なので削除して問題ない。
#
# -o gateway:
#   出力ファイルのパスを指定。gateway という名前のバイナリを生成する。
#
# ./cmd/gateway/:
#   コンパイル対象のパッケージディレクトリ（main パッケージがある場所）
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-w -s" -o gateway ./cmd/gateway/

# =============================================================================
# ステージ2: 実行ステージ（runtime） - 最小限のイメージ
# =============================================================================
#
# 【distroless イメージとは？】
# Google が提供する、アプリの実行に最低限必要なものだけを含むイメージ。
# シェル（bash）、パッケージマネージャー（apt）、その他のツールが一切含まれない。
#
# 【なぜ distroless を使うのか？】
# 1. セキュリティ: 不要なツールがないため、攻撃対象が大幅に減る
#    （例: シェルがないので、コンテナに侵入されてもコマンド実行できない）
# 2. サイズ: 非常に小さい（約2MB）ためデプロイが高速
# 3. シンプル: 余計なものがないため管理が簡単
#
# static-debian12: 静的リンクバイナリ用の distroless イメージ
# （Debian 12 ベースだが、ほぼ何も入っていない最小構成）
FROM gcr.io/distroless/static-debian12

# 実行用の作業ディレクトリを設定
WORKDIR /app

# --from=builder: builder ステージからファイルをコピーする
# ビルドステージで生成した gateway バイナリだけをコピーする
# Go コンパイラやソースコードは含まれない（最小限のイメージ）
COPY --from=builder /build/gateway /app/gateway

# USER: コンテナ内でプロセスを実行するユーザーを指定する
# 【なぜ nonroot ユーザーを使うのか？】
# root（管理者）権限でアプリを実行すると、セキュリティリスクが高い。
# もし脆弱性があった場合、攻撃者がroot権限を得てしまう。
# nonroot ユーザーで実行することで、被害を最小限に抑える。
# distroless イメージには nonroot ユーザーが組み込まれている。
USER nonroot:nonroot

# EXPOSE: コンテナがリッスンするポート番号を宣言する
# これはドキュメント的な意味合いが強く、実際のポート公開は
# docker run の -p オプションや docker-compose の ports で行う
#
# 8080: HTTP（REST API）用ポート
# 50051: gRPC（ロボットとの高速通信）用ポート
#
# 【HTTPとgRPCの違い】
# HTTP/REST: Webブラウザからのリクエストに使う一般的なプロトコル
# gRPC: Google が開発した高速な通信プロトコル。ロボットとのリアルタイム通信に適している
EXPOSE 8080 50051

# ENTRYPOINT: コンテナ起動時に実行されるコマンドを指定する
# コンテナが起動すると /app/gateway バイナリが実行される
#
# 【ENTRYPOINT vs CMD の違い】
# ENTRYPOINT: コンテナの「メインプログラム」を指定する（上書きしにくい）
# CMD: デフォルトのコマンドを指定する（docker run 時に上書きしやすい）
# ENTRYPOINT は「このコンテナは常にこのプログラムを実行する」という意図を示す
#
# 【JSON配列形式（exec form）について】
# ["command", "arg1"] のように JSON 配列で書く形式を「exec form」という。
# シェルを介さずに直接プログラムを実行するため、以下のメリットがある:
# - シグナル（終了信号など）がプログラムに直接届く
# - 不要なシェルプロセスが起動しない
# - セキュリティリスクが低い（シェルインジェクションを防げる）
ENTRYPOINT ["/app/gateway"]
