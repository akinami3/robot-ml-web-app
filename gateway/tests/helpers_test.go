// =============================================================================
// ファイル: helpers_test.go
// 概要: テスト用のヘルパー関数（共通セットアップ処理）を定義するファイル
// =============================================================================
//
// 【ヘルパー関数とは？】
// テストコードでは、複数のテスト関数で同じ準備処理（セットアップ）が必要になることが
// よくあります。その共通処理を1つの関数にまとめたものが「ヘルパー関数」です。
// これにより、コードの重複を避け、メンテナンスしやすいテストコードが書けます。
//
// 【このファイルの役割】
// - モックアダプターを使ったテスト環境のセットアップを提供する
// - 他のテストファイル（例: safety_test.go）からこの関数を呼び出して使う
// - 同じ package tests 内のファイルからアクセスできる
//
// 【パッケージ名について】
// "tests" というパッケージ名にすることで、このディレクトリ内の全テストファイルが
// 同じパッケージに属し、お互いの関数を呼び出せるようになります。
//
// 【テストファイルの命名規則】
// Go では「_test.go」で終わるファイルがテストファイルとして認識される。
// go test コマンド実行時にのみコンパイルされ、本番ビルドには含まれない。
// =============================================================================

// パッケージ宣言: このファイルが属するパッケージ名
// Go では同じディレクトリ内のファイルは同じパッケージ名を使う必要がある
package tests

// =============================================================================
// インポート（外部パッケージの読み込み）
// =============================================================================
//
// 【import文とは？】
// 他のパッケージ（ライブラリ）の機能を使うために、import文で読み込みます。
// Go では使わないimportがあるとコンパイルエラーになる（厳格な言語設計）。
// 複数のパッケージをまとめてインポートする場合は () で囲む。
// =============================================================================
import (
	// adapter パッケージ: ロボットアダプターの登録・管理機能を提供
	// Registry（レジストリ）は、利用可能なロボットアダプターを管理する仕組み
	"github.com/robot-ai-webapp/gateway/internal/adapter"

	// mock パッケージ: テスト用の偽物（モック）アダプターを提供
	// 【モックとは？】
	// 本物のロボットに接続せずにテストするための「偽物」のこと。
	// テストでは本物のハードウェアを使えないので、同じインターフェースを持つ
	// 偽物を使ってテストする。これを「モック」と呼ぶ。
	"github.com/robot-ai-webapp/gateway/internal/adapter/mock"

	// zap パッケージ: Uber社が開発した高性能ロギングライブラリ
	// 【ロギングとは？】
	// プログラムの動作状況を記録すること。デバッグや問題調査に使う。
	"go.uber.org/zap"
)

// =============================================================================
// setupMockRegistry - モックレジストリのセットアップ関数
// =============================================================================
//
// 【この関数の目的】
// テスト用のアダプターレジストリを作成して返す関数。
// テストでは本物のロボットではなく「モック（偽物）」のアダプターを使うため、
// モックファクトリーを登録したレジストリを準備する。
//
// 【関数名が小文字で始まる理由】
// Go では関数名の先頭が小文字 → パッケージ内でのみアクセス可能（非公開）
// 大文字で始まる → パッケージ外からもアクセス可能（公開）
// この関数はテストパッケージ内でのみ使うので小文字で始まる。
//
// 【引数: logger *zap.Logger】
// * はポインタ（参照渡し）。ロガーオブジェクトのメモリアドレスを受け取る。
// 大きな構造体をコピーせずに効率的に渡すためにポインタを使う。
//
// 【戻り値: *adapter.Registry】
// 作成したレジストリのポインタを返す。
// =============================================================================
func setupMockRegistry(logger *zap.Logger) *adapter.Registry {
	// -----------------------------------------------------------------------
	// ステップ1: レジストリの作成
	// -----------------------------------------------------------------------
	// adapter.NewRegistry() でアダプターレジストリを新規作成する
	// 【レジストリパターンとは？】
	// 利用可能なオブジェクトを「登録」して「取得」できる仕組み。
	// ここでは、ロボットの種類ごとにアダプター（接続方法）を登録・管理する。
	// 例: "mock" → テスト用アダプター、"ros" → ROS用アダプター
	registry := adapter.NewRegistry(logger)

	// -----------------------------------------------------------------------
	// ステップ2: モックファクトリーの登録
	// -----------------------------------------------------------------------
	// RegisterFactory() で「mock」という名前でモックアダプターの
	// ファクトリー関数を登録する
	// 【ファクトリーパターンとは？】
	// オブジェクトの作成処理を関数に委譲するデザインパターン。
	// mock.Factory は「モックアダプターを作る関数」そのものを渡している。
	// Go では関数も値として扱えるため、関数を引数として渡すことができる。
	// これを「第一級関数（First-class function）」と呼ぶ。
	registry.RegisterFactory("mock", mock.Factory)

	// -----------------------------------------------------------------------
	// ステップ3: 作成したレジストリを返す
	// -----------------------------------------------------------------------
	// return で呼び出し元にレジストリのポインタを返す
	// これにより、他のテスト関数でこのレジストリを使える
	return registry
}
