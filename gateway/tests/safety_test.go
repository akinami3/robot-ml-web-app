// =============================================================================
// ファイル: safety_test.go
// 概要: 安全機能（速度制限、操作ロック、緊急停止）のテストコード
// =============================================================================
//
// 【Go のテストの基本ルール】
// 1. テストファイルは必ず「_test.go」で終わる名前にする
// 2. テスト関数は必ず「Test」で始まる名前にする（例: TestXxx）
// 3. テスト関数は *testing.T 型の引数を1つ受け取る
// 4. テスト実行は「go test」コマンドで行う
//
// 【テストの3ステップ（Arrange / Act / Assert パターン）】
// テストは一般的に以下の3ステップで書く:
//   Arrange（準備）: テストに必要なオブジェクトやデータを用意する
//   Act（実行）:     テスト対象の処理を実行する
//   Assert（検証）:  結果が期待通りかチェックする
//
// 【なぜテストを書くのか？】
// - コードが正しく動作することを自動的に確認できる
// - コード変更後に既存機能が壊れていないか確認できる（回帰テスト）
// - テストがドキュメントの役割を果たす（使い方の例になる）
// =============================================================================

// パッケージ宣言
// helpers_test.go と同じ "tests" パッケージなので、
// setupMockRegistry() 関数を直接呼び出せる
package tests

// =============================================================================
// インポート
// =============================================================================
import (
	// testing パッケージ: Go 標準のテストフレームワーク
	// テスト結果の報告（成功/失敗）に使う主要な関数:
	//   t.Error()  - テスト失敗を記録するが、テストは続行する
	//   t.Errorf() - フォーマット付きでテスト失敗を記録（続行する）
	//   t.Fatal()  - テスト失敗を記録し、そのテストを即座に中断する
	//   t.Fatalf() - フォーマット付きでテスト失敗を記録（即座に中断）
	"testing"

	// safety パッケージ: ロボットの安全機能（速度制限、ロック、緊急停止）
	"github.com/robot-ai-webapp/gateway/internal/safety"

	// zap パッケージ: 高性能ロギングライブラリ
	"go.uber.org/zap"
)

// =============================================================================
// TestVelocityLimiter_NoClamp - 速度制限：制限内の値はそのまま通る
// =============================================================================
//
// 【テスト関数の命名規則】
// Go のテスト関数名は「Test」で始まり、その後に大文字が続く必要がある。
// 一般的な命名パターン: Test<対象>_<条件やシナリオ>
// 例: TestVelocityLimiter_NoClamp
//   → VelocityLimiter を対象に、NoClamp（制限なし）のケースをテスト
//
// 【引数 t *testing.T について】
// t はテストの実行状態を管理するオブジェクト。
// テストの成功/失敗を報告するメソッドを持っている。
// * はポインタ（参照渡し）を意味する。
// =============================================================================
func TestVelocityLimiter_NoClamp(t *testing.T) {
	// -------------------------------------------------------------------
	// Arrange（準備）: テストに必要なオブジェクトを用意する
	// -------------------------------------------------------------------

	// テスト用の「何も出力しないロガー」を作成
	// 【zap.NewNop() とは？】
	// "Nop" = No Operation（何もしない）の略。
	// テスト実行時にログが大量に出力されると結果が見づらくなるため、
	// ログ出力を無効にした「何もしないロガー」を使う。
	// 本番環境では zap.NewProduction() を使って実際にログ出力する。
	logger := zap.NewNop()

	// 速度リミッターを作成:
	//   第1引数: 直線速度の最大値 = 1.0 m/s
	//   第2引数: 回転速度の最大値 = 2.0 rad/s
	//   第3引数: ロガー（ログ記録器）
	limiter := safety.NewVelocityLimiter(1.0, 2.0, logger)

	// -------------------------------------------------------------------
	// Act（実行）: テスト対象の処理を実行する
	// -------------------------------------------------------------------

	// Limit() メソッドで速度入力を制限する
	// 入力値（LinearX=0.5, AngularZ=1.0）は最大値以内なので、
	// 制限（クランプ）されないはず
	//
	// 【構造体リテラルとは？】
	// safety.VelocityInput{...} は構造体を直接値を指定して作る方法。
	// フィールド名: 値 の形式で指定する。
	result := limiter.Limit(safety.VelocityInput{
		LinearX:  0.5, // X方向の直線速度: 0.5 m/s（最大1.0以内）
		LinearY:  0.0, // Y方向の直線速度: 0.0 m/s
		AngularZ: 1.0, // Z軸周りの回転速度: 1.0 rad/s（最大2.0以内）
	})

	// -------------------------------------------------------------------
	// Assert（検証）: 結果が期待通りかチェックする
	// -------------------------------------------------------------------

	// result.Clamped が true ならテスト失敗
	// 制限内の値なので Clamped（制限された）は false であるべき
	// 【t.Error() について】
	// テスト失敗を記録するが、テスト関数の残りの処理は続行する
	if result.Clamped {
		t.Error("Expected no clamping")
	}

	// 入力値がそのまま出力されているか確認
	// 【t.Errorf() について】
	// フォーマット付きエラーメッセージを出力する
	// %f は浮動小数点数のプレースホルダー（結果の数値が表示される）
	if result.LinearX != 0.5 {
		t.Errorf("Expected linear_x=0.5, got %f", result.LinearX)
	}

	// 回転速度もそのまま出力されているか確認
	if result.AngularZ != 1.0 {
		t.Errorf("Expected angular_z=1.0, got %f", result.AngularZ)
	}
}

// =============================================================================
// TestVelocityLimiter_ClampLinear - 速度制限：直線速度が制限される
// =============================================================================
//
// 【このテストの目的】
// 最大直線速度（1.0 m/s）を超える値（2.0 m/s）を入力した場合、
// 最大値に制限（クランプ）されることを確認する。
// ロボットの安全のために、速度を安全な範囲に制限する機能が正しく動くか検証。
// =============================================================================
func TestVelocityLimiter_ClampLinear(t *testing.T) {
	// Arrange（準備）
	logger := zap.NewNop()
	// 直線速度の最大値: 1.0 m/s、回転速度の最大値: 2.0 rad/s
	limiter := safety.NewVelocityLimiter(1.0, 2.0, logger)

	// Act（実行）
	// LinearX=2.0 は最大値1.0を超えているので制限されるはず
	result := limiter.Limit(safety.VelocityInput{
		LinearX:  2.0, // 最大値(1.0)を超えている！→ クランプされるはず
		LinearY:  0.0,
		AngularZ: 0.0,
	})

	// Assert（検証）
	// Clamped が true であることを確認（制限が発動したはず）
	if !result.Clamped {
		t.Error("Expected clamping")
	}
	// 制限後の値が最大値（1.0）に制限されていることを確認
	if result.LinearX != 1.0 {
		t.Errorf("Expected linear_x=1.0, got %f", result.LinearX)
	}
}

// =============================================================================
// TestVelocityLimiter_ClampAngular - 速度制限：回転速度が制限される
// =============================================================================
//
// 【このテストの目的】
// 最大回転速度（2.0 rad/s）を超える値（5.0 rad/s）を入力した場合、
// 最大値に制限されることを確認する。
// 回転が速すぎるとロボットが不安定になるため、制限が必要。
// =============================================================================
func TestVelocityLimiter_ClampAngular(t *testing.T) {
	// Arrange（準備）
	logger := zap.NewNop()
	limiter := safety.NewVelocityLimiter(1.0, 2.0, logger)

	// Act（実行）
	// AngularZ=5.0 は最大値2.0を超えているので制限されるはず
	// 【LinearY を省略している点について】
	// Go の構造体では、明示的に値を設定しないフィールドは
	// ゼロ値（数値なら 0、文字列なら ""）が自動設定される
	result := limiter.Limit(safety.VelocityInput{
		LinearX:  0.5,
		AngularZ: 5.0, // 最大値(2.0)を大幅に超えている！
	})

	// Assert（検証）
	// 制限が発動していることを確認
	if !result.Clamped {
		t.Error("Expected clamping")
	}
	// 制限後の回転速度が最大値（2.0）に制限されていることを確認
	if result.AngularZ != 2.0 {
		t.Errorf("Expected angular_z=2.0, got %f", result.AngularZ)
	}
}

// =============================================================================
// TestOperationLock_AcquireRelease - 操作ロック：取得と解放のテスト
// =============================================================================
//
// 【操作ロック（OperationLock）とは？】
// 同じロボットを同時に複数のユーザーが操作すると危険なため、
// 「排他制御」の仕組みが必要。操作ロックは、あるユーザーがロボットを
// 操作している間、他のユーザーが操作できないようにする仕組み。
//
// 【排他制御（Mutual Exclusion）とは？】
// 共有リソース（ここではロボット）に同時に1人だけがアクセスできるようにすること。
// データベースの行ロック、ファイルロックなど、プログラミングの多くの場面で使われる。
//
// 【このテストの流れ】
// 1. user-1 がロボット "robot-1" のロックを取得する
// 2. user-1 がロックを持っていることを確認する
// 3. user-2 が同じロボットのロックを取得しようとして失敗することを確認する
// 4. user-1 がロックを解放する
// 5. user-2 がロックを取得できることを確認する
// =============================================================================
func TestOperationLock_AcquireRelease(t *testing.T) {
	// -------------------------------------------------------------------
	// Arrange（準備）
	// -------------------------------------------------------------------
	logger := zap.NewNop()

	// 操作ロックを作成（タイムアウト: 300秒 = 5分）
	// 300*1000*1000*1000 はナノ秒単位で300秒を表す
	// 【ナノ秒とは？】 1秒 = 1,000,000,000 ナノ秒
	// Go の time.Duration はナノ秒単位の整数値。
	// 通常は time.Second * 300 のように書くこともできるが、
	// ここでは直接ナノ秒値を指定している。
	//
	// 【タイムアウトの意味】
	// ロックを取得したまま何もしないと、300秒後に自動的にロックが解放される。
	// ユーザーが接続を切断した場合にロックが永久に残ることを防ぐため。
	lock := safety.NewOperationLock(300*1000*1000*1000, logger) // 300 sec

	// -------------------------------------------------------------------
	// Act & Assert: ロックの取得
	// -------------------------------------------------------------------

	// user-1 が robot-1 のロックを取得する
	// 【複数の戻り値について】
	// Go の関数は複数の値を返すことができる。
	// 慣例として、最後の戻り値にエラー（error型）を返す。
	// info にはロック情報（誰がいつ取得したか等）、err にはエラーが入る。
	info, err := lock.Acquire("robot-1", "user-1")

	// 【t.Fatalf() について】
	// テスト失敗を記録し、このテスト関数を即座に中断する。
	// t.Error() は続行するが、t.Fatal() は中断する。
	// ロック取得に失敗したら以降のテストが意味をなさないので Fatal を使う。
	// %v はどんな型でも文字列化して表示するプレースホルダー。
	if err != nil {
		t.Fatalf("Failed to acquire lock: %v", err)
	}

	// 取得したロック情報のユーザーIDが正しいか確認
	if info.UserID != "user-1" {
		t.Errorf("Expected user_id=user-1, got %s", info.UserID)
	}

	// -------------------------------------------------------------------
	// Assert: ロックの確認（CheckLock）
	// -------------------------------------------------------------------

	// user-1 がロックを持っているか確認 → true であるべき
	if !lock.CheckLock("robot-1", "user-1") {
		t.Error("Expected lock to be held by user-1")
	}

	// user-2 はロックを持っていないか確認 → false であるべき
	if lock.CheckLock("robot-1", "user-2") {
		t.Error("Expected lock NOT to be held by user-2")
	}

	// -------------------------------------------------------------------
	// Act & Assert: 別のユーザーによるロック取得の失敗
	// -------------------------------------------------------------------

	// user-2 が同じロボットのロックを取得しようとする → 失敗するはず
	// 【エラーハンドリングのパターン】
	// Go では例外（throw/catch）の代わりに、エラーを戻り値で返す。
	// err == nil → エラーなし（成功）
	// err != nil → エラーあり（失敗）
	// _ （アンダースコア）は「使わない値」を捨てる記法（ブランク識別子）
	_, err = lock.Acquire("robot-1", "user-2")
	if err == nil {
		t.Error("Expected error when another user tries to acquire")
	}

	// -------------------------------------------------------------------
	// Act: ロックの解放
	// -------------------------------------------------------------------

	// user-1 がロックを解放する
	// 【短縮変数宣言 := と 代入 = の違い】
	// err = は既存の変数に再代入（上で宣言済みの err に代入）
	// err := は新しい変数を宣言して代入
	err = lock.Release("robot-1", "user-1")
	if err != nil {
		t.Fatalf("Failed to release lock: %v", err)
	}

	// -------------------------------------------------------------------
	// Assert: 解放後に別ユーザーが取得できることを確認
	// -------------------------------------------------------------------

	// ロック解放後、user-2 がロックを取得できるはず
	_, err = lock.Acquire("robot-1", "user-2")
	if err != nil {
		t.Fatalf("user-2 should be able to acquire after release: %v", err)
	}
}

// =============================================================================
// TestEStopManager - 緊急停止（E-Stop）機能のテスト
// =============================================================================
//
// 【緊急停止（E-Stop / Emergency Stop）とは？】
// ロボットの動作を即座に停止させる安全機能。
// 物理的なロボットには赤い緊急停止ボタンがあるが、
// ソフトウェアでも同様の機能を実装する必要がある。
//
// 【このテストの流れ】
// 1. 初期状態で緊急停止が非アクティブであることを確認
// 2. 緊急停止を発動する
// 3. 緊急停止がアクティブになったことを確認
// 4. 緊急停止を解除する
// 5. 非アクティブに戻ったことを確認
//
// 【テストでヘルパー関数を使う例】
// setupMockRegistry() は helpers_test.go に定義されたヘルパー関数。
// 同じパッケージ内なので直接呼び出せる。
// =============================================================================
func TestEStopManager(t *testing.T) {
	// -------------------------------------------------------------------
	// Arrange（準備）
	// -------------------------------------------------------------------
	logger := zap.NewNop()

	// ヘルパー関数でモックレジストリを作成（helpers_test.go で定義）
	// これにより、本物のロボットに接続せずにテストできる
	// 引数に logger を渡して、レジストリ内でもログ出力を抑制する
	registry := setupMockRegistry(logger)

	// 緊急停止マネージャーを作成
	// レジストリを渡すことで、緊急停止時にロボットへ停止命令を送信できる
	estop := safety.NewEStopManager(registry, logger)

	// -------------------------------------------------------------------
	// Assert: 初期状態の確認
	// -------------------------------------------------------------------

	// 初期状態では緊急停止は非アクティブ（作動していない）はず
	if estop.IsActive("robot-1") {
		t.Error("E-Stop should not be active initially")
	}

	// -------------------------------------------------------------------
	// Act: 緊急停止の発動
	// -------------------------------------------------------------------

	// 緊急停止を発動する
	// 引数: コンテキスト(nil)、ロボットID、ユーザーID、理由
	// 【nil について】
	// nil は Go でのヌル値（何もないことを表す値）。
	// ここでは context を nil にしている（ユニットテストではコンテキスト不要）。
	// 本番コードでは context.Background() を使うのが望ましい。
	//
	// 【_ = という書き方】
	// 戻り値のエラーを明示的に無視している。
	// テストでは状態管理のみをテストしており、アダプター接続のエラーは無視する。
	_ = estop.Activate(nil, "robot-1", "user-1", "test")

	// -------------------------------------------------------------------
	// Assert: 緊急停止がアクティブであることを確認
	// -------------------------------------------------------------------

	// Activate の後なので IsActive は true を返すはず
	if !estop.IsActive("robot-1") {
		t.Error("E-Stop should be active after activation")
	}

	// -------------------------------------------------------------------
	// Act & Assert: 緊急停止の解除
	// -------------------------------------------------------------------

	// 緊急停止を解除する
	// 発動したユーザー（user-1）だけが解除できるようにすることで安全性を確保
	estop.Release("robot-1", "user-1")

	// 解除後は非アクティブに戻るはず
	if estop.IsActive("robot-1") {
		t.Error("E-Stop should not be active after release")
	}
}

// =============================================================================
// 【補足: テーブル駆動テスト（Table-Driven Tests）について】
// =============================================================================
//
// Go では「テーブル駆動テスト」というパターンがよく使われます。
// これは、テストケースをテーブル（配列/スライス）として定義し、
// ループで回す方法です。同じロジックに対して複数の入力パターンを
// テストする場合に特に有効です。
//
// 例:
//   tests := []struct {
//       name     string   // テストケース名
//       input    float64  // 入力値
//       expected float64  // 期待される結果
//       clamped  bool     // 制限されるか
//   }{
//       {"normal",  0.5, 0.5, false},
//       {"exceed",  2.0, 1.0, true},
//       {"negative",-2.0,-1.0, true},
//   }
//
//   for _, tt := range tests {
//       t.Run(tt.name, func(t *testing.T) {
//           // テストロジック
//       })
//   }
//
// メリット:
// - テストケースの追加が簡単（テーブルに行を追加するだけ）
// - テストコードの重複を減らせる
// - t.Run() でサブテストとして実行でき、個別に確認できる
//
// 上記の TestVelocityLimiter_NoClamp, _ClampLinear, _ClampAngular は
// テーブル駆動テストで1つにまとめることもできます。
// =============================================================================
