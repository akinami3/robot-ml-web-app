# =============================================================================
# Gateway - Development Dockerfile (with hot reload via air)
# ゲートウェイサービスの開発用Dockerイメージ（ホットリロード機能付き）
# =============================================================================
#
# 【本番用 Dockerfile との違い】
# 本番用（Dockerfile）:
#   - マルチステージビルドで最小限のイメージを作る
#   - distroless ベースで、シェルすら入っていない
#   - コンパイル済みバイナリのみを含む
#
# 開発用（Dockerfile.dev、このファイル）:
#   - Go の開発ツールがすべて入っている
#   - ホットリロード（air）でコード変更時に自動再ビルド
#   - デバッグしやすい環境
#
# 【ホットリロード（Hot Reload）とは？】
# ソースコードを変更すると、自動的にプログラムを再ビルド・再起動する機能。
# 手動でビルドし直す必要がなく、開発効率が大幅に向上する。
# Web 開発では一般的な機能（Node.js の nodemon、Python の Flask debug mode など）
#
# 【なぜマルチステージビルドではないのか？】
# 開発用では Go のツールチェーン（コンパイラ等）が常に必要なため、
# 1つのステージだけで構成している。
# =============================================================================

# FROM: ベースイメージの指定
# golang:1.23-alpine: Go 1.23 がインストールされた Alpine Linux
# 開発用なので Go のツールチェーン（コンパイラ、ツールなど）がすべて含まれる
FROM golang:1.23-alpine

# WORKDIR: 作業ディレクトリを /app/src に設定
# 以降のすべてのコマンドは /app/src ディレクトリ内で実行される
WORKDIR /app/src

# =============================================================================
# ホットリロードツール「air」と依存ツールのインストール
# =============================================================================
#
# RUN: コンテナ内でコマンドを実行する
# && で複数のコマンドを1つの RUN 命令にまとめている
# 【なぜ1つの RUN にまとめるのか？】
# 各 RUN 命令は新しいレイヤーを作成する。
# まとめることでレイヤー数を減らし、イメージサイズを最適化できる。
#
# apk add --no-cache git:
#   Alpine のパッケージマネージャーで git をインストール
#   --no-cache: キャッシュを保存しない（イメージサイズ削減）
#
# go install github.com/air-verse/air@v1.61.7:
#   air（ホットリロードツール）の v1.61.7 をインストール
#   @v1.61.7: 特定のバージョンを指定（再現性のため）
#
# 【air（エアー）とは？】
# Go 用のホットリロードツール。ファイルの変更を監視し、
# 変更を検出すると自動でビルドと再起動を行う。
# 設定ファイル（.air.toml）でカスタマイズできる。
RUN apk add --no-cache git && \
    go install github.com/air-verse/air@v1.61.7

# =============================================================================
# 依存関係のインストール
# =============================================================================
#
# 本番用 Dockerfile と同じく、依存関係ファイルを先にコピーして
# レイヤーキャッシュを活用する。
# ソースコードが変わっても、依存関係が変わっていなければ
# このステップはキャッシュが使われて高速に処理される。
COPY go.mod go.sum ./
RUN go mod download

# ソースコード全体をコンテナにコピーする
# 【開発時のボリュームマウントについて】
# 実際の開発では、docker-compose.yml で「ボリュームマウント」を設定して、
# ホストマシンのソースコードをコンテナ内に直接マウントすることが多い。
# これにより、ホストでファイルを編集するとコンテナ内にも即座に反映される。
# ボリュームマウントの設定例（docker-compose.yml）:
#   volumes:
#     - ./gateway:/app/src
COPY . .

# EXPOSE: リッスンするポートの宣言
# 8080: HTTP（REST API）用
# 50051: gRPC 用
# ドキュメント目的の宣言で、実際のポート公開は docker-compose で行う
EXPOSE 8080 50051

# =============================================================================
# コンテナ起動時のコマンド
# =============================================================================
#
# CMD: コンテナ起動時に実行されるデフォルトコマンド
# air を -c オプション付きで起動し、設定ファイル .air.toml を読み込む
#
# 【CMD と ENTRYPOINT の使い分け】
# ここでは CMD を使っている（本番用では ENTRYPOINT を使っていた）
# CMD は docker run 時に簡単に上書きできるため、開発用に適している。
# 例: docker run <image> /bin/sh でシェルに入ることもできる
#
# 【air の動作の流れ】
# 1. .air.toml の設定を読み込む
# 2. 指定されたディレクトリ・拡張子のファイルを監視開始
# 3. ファイル変更を検出すると、ビルドコマンドを実行
# 4. ビルド成功後、新しいバイナリを起動
# 5. 次のファイル変更まで待機（古いプロセスは停止される）
CMD ["air", "-c", ".air.toml"]
