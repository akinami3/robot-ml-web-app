# =============================================================================
# Nginx 設定ファイル（フロントエンド用）
# =============================================================================
#
# 【Nginxとは？】
# 高性能なWebサーバーソフトウェアです。主な役割:
#   1. 静的ファイル配信: HTML, CSS, JSファイルをブラウザに送る
#   2. リバースプロキシ: ブラウザからのAPIリクエストをバックエンドに転送する
#   3. ロードバランサー: 複数サーバーに負荷を分散（今回は使用しない）
#
# 【この設定ファイルの全体像】
#   ブラウザ → Nginx（ポート80）
#     ├── /          → React SPAの静的ファイルを返す
#     ├── /api/      → バックエンド（FastAPI）に転送
#     ├── /ws        → ゲートウェイ（WebSocket）に転送
#     └── *.js,*.css → キャッシュ付きで静的ファイルを返す
# =============================================================================

# 【serverブロック】1つの仮想サーバー（Webサイト）の設定
# Nginxは複数のサーバーブロックを持てるため、
# 1台のサーバーで複数のWebサイトをホストできます
server {
    # 【listen 80】HTTP通信のポート80番でリクエストを受け付ける
    # ポート80はHTTPの標準ポート（HTTPSは443）
    listen 80;

    # 【server_name _】すべてのホスト名にマッチするワイルドカード
    # 特定のドメインに限定する場合は server_name example.com; のように指定
    server_name _;

    # 【root】静的ファイルのルートディレクトリ
    # Dockerfileでビルド成果物をこのパスにコピーしています
    root /usr/share/nginx/html;

    # 【index】ディレクトリにアクセスされた時に返すデフォルトファイル
    index index.html;

    # =========================================================================
    # Gzip圧縮設定
    # =========================================================================
    # 【Gzipとは？】レスポンスデータを圧縮してブラウザに送る仕組み
    # ファイルサイズが小さくなるため、ページの読み込みが速くなります
    # ブラウザは自動的にGzipを解凍して表示します

    # 【gzip on】Gzip圧縮を有効化
    gzip on;

    # 【gzip_types】圧縮対象のMIMEタイプ（ファイル種類）を指定
    # text/plain      → テキストファイル
    # text/css        → CSSファイル
    # application/json → JSONデータ（API通信）
    # application/javascript → JavaScriptファイル
    # text/xml, application/xml → XMLファイル
    # text/javascript → JavaScriptファイル（古い形式）
    # image/svg+xml   → SVG画像
    # ※ 画像（JPEG, PNG）は既に圧縮済みなので対象外
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml text/javascript image/svg+xml;

    # 【gzip_min_length 256】256バイト以下のファイルは圧縮しない
    # 小さいファイルを圧縮すると、圧縮/解凍のオーバーヘッドの方が大きくなるため
    gzip_min_length 256;

    # =========================================================================
    # SPA（Single Page Application）フォールバック
    # =========================================================================
    # 【locationブロック】特定のURLパスに対する処理を定義
    # location / はすべてのリクエストにマッチ（他のlocationに一致しない場合）
    location / {
        # 【try_files】リクエストされたファイルの探索順序を指定
        #   $uri            → リクエストされたURLのファイルを探す（例: /about.html）
        #   $uri/           → ディレクトリとして探す（例: /about/index.html）
        #   /index.html     → 上記が見つからなければ index.html を返す
        #
        # 【なぜ /index.html にフォールバック？】
        # React（SPA）はクライアントサイドルーティングを使用します:
        #   - /dashboard や /settings はサーバー上にはファイルが存在しない
        #   - すべて index.html を返し、Reactのルーターがページを表示する
        #   - これがないと、直接URLアクセスやページ更新時に404エラーになる
        try_files $uri $uri/ /index.html;
    }

    # =========================================================================
    # APIプロキシ（リバースプロキシ）
    # =========================================================================
    # 【リバースプロキシとは？】
    # ブラウザからのリクエストを別のサーバーに転送（中継）する仕組み
    # ブラウザ → Nginx → バックエンド（FastAPI）
    #
    # 【なぜプロキシが必要？】
    # - ブラウザの同一オリジンポリシー（CORS）を回避できる
    # - フロントエンドとバックエンドを同じドメインで提供できる
    # - バックエンドのサーバー構成をブラウザから隠蔽できる
    location /api/ {
        # 【proxy_pass】リクエストを転送する先のサーバーを指定
        # Docker Compose のサービス名「backend」でアクセス
        # 例: ブラウザが /api/users → バックエンドの http://backend:8000/api/users
        proxy_pass http://backend:8000;

        # 【proxy_set_header】転送するリクエストにヘッダーを追加
        # Host: 元のホスト名を転送先に伝える
        proxy_set_header Host $host;

        # X-Real-IP: 実際のクライアント（ブラウザ）のIPアドレスを伝える
        proxy_set_header X-Real-IP $remote_addr;

        # X-Forwarded-For: プロキシを経由したクライアントのIPアドレスチェーン
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # X-Forwarded-Proto: 元のリクエストのプロトコル（http or https）を伝える
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # =========================================================================
    # WebSocketプロキシ
    # =========================================================================
    # 【WebSocketとは？】
    # サーバーとブラウザ間で双方向リアルタイム通信を可能にするプロトコル
    # 通常のHTTPは「リクエスト→レスポンス」の一方向だが、
    # WebSocketは一度接続すると、サーバーからもデータをプッシュできる
    # ロボットの状態やセンサーデータのリアルタイム表示に最適
    location /ws {
        # WebSocketの転送先（ゲートウェイサーバー）
        proxy_pass http://gateway:8080;

        # 【proxy_http_version 1.1】HTTP/1.1を使用
        # WebSocketのアップグレードにはHTTP/1.1が必要
        proxy_http_version 1.1;

        # 【Upgrade ヘッダー】
        # HTTPからWebSocketへのプロトコルアップグレードを要求
        # $http_upgrade にはブラウザが送った "websocket" が入る
        proxy_set_header Upgrade $http_upgrade;

        # 【Connection "upgrade"】
        # 接続をアップグレードすることをサーバーに伝える
        proxy_set_header Connection "upgrade";

        # ホスト名とクライアントIPを転送
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;

        # 【proxy_read_timeout 86400】読み取りタイムアウトを24時間に設定
        # 86400秒 = 24時間
        # WebSocketは長時間接続が前提のため、通常のHTTPより長いタイムアウトが必要
        # デフォルト（60秒）だと、データ送信がない場合に接続が切れてしまう
        proxy_read_timeout 86400;
    }

    # =========================================================================
    # 静的アセットのキャッシュ設定
    # =========================================================================
    # 【正規表現によるlocation】
    # ~* は大文字小文字を区別しない正規表現マッチ
    # \.(js|css|png|...)$ → 指定した拡張子で終わるファイルにマッチ
    #
    # 【キャッシュとは？】
    # ブラウザがファイルをローカルに保存し、次回アクセス時に再ダウンロードしない仕組み
    # → ページ読み込みが大幅に高速化される
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff2?)$ {
        # 【expires 1y】キャッシュ有効期間を1年に設定
        # Viteはビルド時にファイル名にハッシュを追加（例: app.a1b2c3.js）
        # ファイル内容が変わるとハッシュも変わるため、長期キャッシュでも安全
        expires 1y;

        # 【Cache-Control ヘッダー】
        # public: CDNやプロキシでもキャッシュ可能
        # immutable: ファイルは変更されない（ブラウザが再検証リクエストを送らない）
        add_header Cache-Control "public, immutable";
    }

    # =========================================================================
    # セキュリティヘッダー
    # =========================================================================
    # Webアプリケーションを一般的な攻撃から守るためのHTTPヘッダー

    # 【X-Frame-Options "SAMEORIGIN"】
    # このサイトを <iframe> で埋め込めるのは同じオリジン（ドメイン）のみ
    # クリックジャッキング攻撃（透明なiframeを重ねてクリックを奪う）を防止
    # "always" → エラーレスポンス（404, 500など）にもヘッダーを付与
    add_header X-Frame-Options "SAMEORIGIN" always;

    # 【X-Content-Type-Options "nosniff"】
    # ブラウザによるMIMEタイプの推測（スニッフィング）を禁止
    # 例: text/plainのファイルをJavaScriptとして実行する攻撃を防止
    add_header X-Content-Type-Options "nosniff" always;

    # 【Referrer-Policy "strict-origin-when-cross-origin"】
    # 別サイトへのリンクをクリックした際に、どこから来たか（リファラー）の送信を制御
    # same-origin: 完全なURLを送信, cross-origin: オリジン（ドメイン）のみ送信
    # プライバシー保護のため、詳細なURLパスを外部サイトに漏らさない
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
}
