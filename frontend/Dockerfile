# =============================================================================
# フロントエンド用 Dockerfile（本番環境向け）
# =============================================================================
#
# 【Dockerfileとは？】
# アプリケーションの「実行環境」を自動的に構築するための設計図です。
# どのOS・ソフトウェアを使い、どうやってアプリを準備するかを記述します。
#
# 【マルチステージビルドとは？】
# Dockerイメージを複数の段階（ステージ）に分けて構築する手法です。
# ① ビルドステージ: アプリをコンパイル（ビルド）する段階
# ② プロダクションステージ: 実際に動かす軽量な段階
# ビルドに必要なツール（node_modulesなど）を最終イメージに含めないため、
# イメージサイズが大幅に小さくなります（数百MB → 数十MB）。
# =============================================================================

# -----------------------------------------------------------------------------
# ステージ1: ビルドステージ（Build Stage）
# -----------------------------------------------------------------------------
# 【FROM】ベースとなるDockerイメージを指定します
# 【node:20-alpine】Node.js v20 の Alpine Linux版
#   - Alpine Linux: 通常のLinux（~100MB）より遥かに軽量（~5MB）な
#     最小構成のLinuxディストリビューション
#   - アプリのビルドに必要なNode.js環境を提供します
# 【AS build】このステージに「build」という名前をつけています
#   後のステージから「build」という名前でこのステージの成果物を参照できます
# -----------------------------------------------------------------------------
FROM node:20-alpine AS build

# 【WORKDIR】コンテナ内の作業ディレクトリを設定します
# 以降のコマンドはすべてこのディレクトリ内で実行されます
# ディレクトリが存在しない場合は自動的に作成されます
WORKDIR /app

# 【COPY】ホストマシンのファイルをコンテナ内にコピーします
# まず package.json と package-lock.json だけを先にコピーします
# 【なぜ先にコピー？】Dockerのレイヤーキャッシュの仕組みを活用するため:
#   - package.jsonが変わらなければ、npm ci の結果がキャッシュされる
#   - ソースコードだけ変更した場合、依存関係の再インストールをスキップできる
#   - ビルド時間を大幅に短縮できます！
# 【package-lock.json*】末尾の * はワイルドカード
#   package-lock.json が存在しなくてもエラーにならないようにしています
COPY package.json package-lock.json* ./

# 【RUN】コンテナ内でコマンドを実行します
# 【npm ci と npm install の違い】
#   npm install: package.jsonを基に依存関係を解決（バージョンが変わる可能性あり）
#   npm ci（Clean Install）:
#     - package-lock.json を厳密に使用（全く同じバージョンをインストール）
#     - node_modules を一度削除してからインストール（クリーンな状態）
#     - 再現性が高く、CI/CD環境や本番ビルドに最適
#     - npm install より高速
RUN npm ci

# ソースコード全体をコンテナにコピー
COPY . .

# 【npm run build】React + Viteでアプリケーションをビルド
# TypeScript → JavaScript への変換、バンドル（ファイル結合）、最適化を行い、
# dist/ ディレクトリに静的ファイル（HTML, CSS, JS）を出力します
RUN npm run build

# -----------------------------------------------------------------------------
# ステージ2: プロダクションステージ（Production Stage）
# -----------------------------------------------------------------------------
# 【nginx:alpine】軽量なWebサーバー「Nginx」のAlpine版
# 【Nginxとは？】高性能なWebサーバー/リバースプロキシ
#   - 静的ファイル（HTML, CSS, JS）の配信に最適
#   - Node.jsサーバーを動かす必要がなく、非常に軽量
#   - 大量の同時接続を効率的に処理できる
# ビルドステージのNode.js環境は含まれず、Nginxだけの軽量イメージになります
# -----------------------------------------------------------------------------
FROM nginx:alpine

# 【Nginx設定ファイルのコピー】
# カスタムのNginx設定を、Nginxのデフォルト設定ディレクトリにコピーします
# これにより、SPAのルーティングやAPIプロキシなどを設定できます
COPY nginx.conf /etc/nginx/conf.d/default.conf

# 【--from=build】ビルドステージ（AS buildで名付けた）から成果物をコピー
# ビルドで生成された dist/ ディレクトリの中身を
# Nginxの公開ディレクトリにコピーします
# これが実際にユーザーに配信されるファイルです
COPY --from=build /app/dist /usr/share/nginx/html

# 【EXPOSE】コンテナがリッスンするポート番号を宣言します
# HTTPの標準ポート80番を使用
# ※ 実際のポート公開は docker run -p で行います（EXPOSEは文書化の役割）
EXPOSE 80

# 【HEALTHCHECK】コンテナの健康状態を定期的にチェックする設定
# Docker がコンテナの動作状況を監視するために使います
#   --interval=30s  : 30秒ごとにチェック
#   --timeout=3s    : チェックが3秒以内に完了しなければ失敗
#   --start-period=5s : 起動後5秒間はチェックを猶予（起動時間を考慮）
#   --retries=3     : 3回連続失敗でunhealthy（異常）と判定
# 【CMD】ヘルスチェックで実行するコマンド
#   wget でローカルのWebサーバーにアクセスし、応答があるか確認
#   -q: 静かモード（出力なし）, --spider: ダウンロードせずに確認のみ
#   || exit 1: アクセス失敗時にエラーコード1を返す
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget -q --spider http://localhost/ || exit 1
