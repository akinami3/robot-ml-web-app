// =============================================================================
// Gateway Service 定義ファイル（gRPC / Protocol Buffers）
// =============================================================================
//
// 【このファイルの役割】
// このファイルは「.proto（プロトファイル）」と呼ばれ、gRPC通信の設計図です。
// バックエンド（Python）とゲートウェイ（Go）の間で、どんなデータをやり取りするかを
// 定義しています。
//
// 【gRPC とは？】
// gRPC は Google が開発した高速な通信フレームワークです。
// 通常の REST API（JSON を使う）と違い、バイナリ形式（Protocol Buffers）で
// データを送受信するため、以下のメリットがあります：
//   - 通信速度が速い（バイナリなのでデータサイズが小さい）
//   - 型安全（送受信するデータの型が厳密に決まっている）
//   - ストリーミング対応（データを連続的に送り続けることができる）
//   - 多言語対応（Python, Go, Java, C++ など様々な言語で使える）
//
// 【REST API との違い】
//   REST API: クライアント → HTTP/JSON → サーバー（テキストベース）
//   gRPC:     クライアント → HTTP/2 + Protobuf → サーバー（バイナリベース）
//
// 【このファイルから自動生成されるもの】
// このファイルをコンパイルすると、各言語用のコードが自動生成されます：
//   - Python 用: gateway_service_pb2.py, gateway_service_pb2_grpc.py
//   - Go 用:     gateway_service.pb.go, gateway_service_grpc.pb.go
// =============================================================================

// ---------------------------------------------------------------------------
// syntax = "proto3";
// ---------------------------------------------------------------------------
// Protocol Buffers のバージョンを指定します。
// 「proto3」は最新の構文バージョンで、以下の特徴があります：
//   - フィールドはすべてオプショナル（省略可能）
//   - デフォルト値が自動的に設定される（文字列=""、数値=0、bool=false）
//   - proto2 より構文がシンプルで書きやすい
// 必ずファイルの最初の行に書く必要があります。
// ---------------------------------------------------------------------------
syntax = "proto3";

// ---------------------------------------------------------------------------
// package robotai;
// ---------------------------------------------------------------------------
// パッケージ名の宣言です。名前空間（namespace）として機能し、
// 他の .proto ファイルとメッセージ名が衝突するのを防ぎます。
// 例：robotai.RobotCommand と other.RobotCommand は別物として区別できます。
// ---------------------------------------------------------------------------
package robotai;

// ---------------------------------------------------------------------------
// option go_package
// ---------------------------------------------------------------------------
// Go 言語でコード生成する際のパッケージパスを指定します。
// Go のモジュールシステムでは、パッケージのインポートパスが必要なため、
// ここで明示的に指定しています。
// Python や他の言語では、この設定は無視されます。
// ---------------------------------------------------------------------------
option go_package = "github.com/robot-ai-webapp/gateway/internal/bridge/proto";

// ---------------------------------------------------------------------------
// import 文
// ---------------------------------------------------------------------------
// 他の .proto ファイルからメッセージ定義を読み込みます。
// Java や Python の import と同じ概念です。
//
// google/protobuf/timestamp.proto:
//   Google が提供する標準ライブラリ。日時（タイムスタンプ）を表す型を定義。
//   独自に日時型を作るより、この標準型を使う方が安全で互換性があります。
//
// sensor.proto:
//   ロボットのセンサーデータ（LiDAR、カメラ等）の型定義を読み込み。
//   SensorData メッセージなどが定義されています。
//
// command.proto:
//   ロボットへのコマンド（移動指示等）の型定義を読み込み。
//   RobotCommand, CommandAck などが定義されています。
// ---------------------------------------------------------------------------
import "google/protobuf/timestamp.proto";
import "sensor.proto";
import "command.proto";

// =============================================================================
// Gateway Service - Backend ↔ Gateway gRPC communication
// =============================================================================
//
// 【service とは？】
// gRPC の「サービス」は、API のエンドポイント集をまとめたものです。
// REST API でいうところの「コントローラー」や「ルーター」に相当します。
//
// 【rpc メソッドとは？】
// 各 rpc は 1 つの API エンドポイントを定義します。
// 書式: rpc メソッド名(リクエスト型) returns (レスポンス型);
//
// 【4 種類の通信パターン】
// gRPC には 4 種類の通信パターンがあります：
//
// 1. Unary（単項）: 1リクエスト → 1レスポンス（通常の API 呼び出し）
//    rpc Method(Request) returns (Response);
//
// 2. Server Streaming（サーバーストリーミング）: 1リクエスト → 複数レスポンス
//    rpc Method(Request) returns (stream Response);
//    → センサーデータのように、継続的にデータを受信したい場合に使用
//
// 3. Client Streaming: 複数リクエスト → 1レスポンス
//    rpc Method(stream Request) returns (Response);
//
// 4. Bidirectional Streaming: 複数リクエスト ↔ 複数レスポンス
//    rpc Method(stream Request) returns (stream Response);
//
// このサービスでは、パターン 1（Unary）と パターン 2（Server Streaming）を使用。
// =============================================================================

service GatewayService {

  // -------------------------------------------------------------------------
  // SendCommand - ロボットにコマンドを送信する
  // -------------------------------------------------------------------------
  // 通信パターン: Unary（単項 RPC）
  // リクエスト: RobotCommand（command.proto で定義）
  //   → 送りたいコマンドの内容（例：前進、回転、停止 など）
  // レスポンス: CommandAck（command.proto で定義）
  //   → コマンドが受理されたかどうかの確認応答（Acknowledgement）
  //
  // 使用例：ユーザーが Web UI で「前進」ボタンを押す
  //   → バックエンドが RobotCommand を作成
  //   → gRPC でゲートウェイに送信
  //   → ゲートウェイがロボットに転送
  //   → CommandAck（成功/失敗）が返る
  // -------------------------------------------------------------------------
  // Send a command to a robot via the gateway
  rpc SendCommand(RobotCommand) returns (CommandAck);

  // -------------------------------------------------------------------------
  // EmergencyStopRobot - 特定のロボットを緊急停止させる
  // -------------------------------------------------------------------------
  // 通信パターン: Unary（単項 RPC）
  // 安全機能の中で最も重要なメソッドの一つです。
  // ロボットが危険な動作をした場合、即座に停止させます。
  // robot_id で停止対象を指定し、reason に停止理由を記録します。
  // -------------------------------------------------------------------------
  // Emergency stop a specific robot
  rpc EmergencyStopRobot(EmergencyStopRequest) returns (EmergencyStopResponse);

  // -------------------------------------------------------------------------
  // EmergencyStopAll - すべてのロボットを一斉に緊急停止させる
  // -------------------------------------------------------------------------
  // 通信パターン: Unary（単項 RPC）
  // 全ロボット一括停止。災害時や重大な異常検知時に使用。
  // レスポンスには、停止成功数と失敗したロボットの ID が含まれます。
  // -------------------------------------------------------------------------
  // Emergency stop ALL robots
  rpc EmergencyStopAll(EmergencyStopAllRequest) returns (EmergencyStopAllResponse);

  // -------------------------------------------------------------------------
  // GetRobotStatus - ロボットの現在の状態を取得する
  // -------------------------------------------------------------------------
  // 通信パターン: Unary（単項 RPC）
  // 指定したロボットのバッテリー残量、位置、接続状態などを取得。
  // RobotStatus は sensor.proto で定義されています。
  // -------------------------------------------------------------------------
  // Get current robot status
  rpc GetRobotStatus(GetRobotStatusRequest) returns (RobotStatus);

  // -------------------------------------------------------------------------
  // ListConnectedRobots - 接続中の全ロボット一覧を取得する
  // -------------------------------------------------------------------------
  // 通信パターン: Unary（単項 RPC）
  // 現在ゲートウェイに接続されているすべてのロボットの情報を返します。
  // ダッシュボード画面で「接続中のロボット一覧」を表示する際に使用。
  // -------------------------------------------------------------------------
  // List all connected robots
  rpc ListConnectedRobots(ListConnectedRobotsRequest) returns (ListConnectedRobotsResponse);

  // -------------------------------------------------------------------------
  // StreamSensorData - ロボットのセンサーデータをストリーミングで受信する
  // -------------------------------------------------------------------------
  // 通信パターン: ★ Server Streaming（サーバーストリーミング RPC）★
  //
  // 「stream」キーワードがレスポンス側についている点に注目！
  // これにより、1 回のリクエストに対して、サーバー（ゲートウェイ）から
  // 連続的にデータが送られてきます。
  //
  // 用途：リアルタイムでセンサーデータ（LiDAR、カメラ、IMU 等）を
  // Web UI に表示するために使います。
  //
  // REST API でこれを実現しようとすると、ポーリング（定期的な問い合わせ）が
  // 必要ですが、gRPC ストリーミングなら効率的にリアルタイム通信できます。
  //
  // topics フィールドで受信したいセンサーの種類を指定できます。
  // 空の場合はすべてのセンサーデータが送られます。
  // -------------------------------------------------------------------------
  // Stream sensor data from a robot
  rpc StreamSensorData(StreamSensorDataRequest) returns (stream SensorData);

  // -------------------------------------------------------------------------
  // AcquireOperationLock / ReleaseOperationLock - 操作ロックの管理
  // -------------------------------------------------------------------------
  // 複数ユーザーが同時に同じロボットを操作しないようにするための
  // 排他制御（ロック）機能です。
  //
  // AcquireOperationLock: ロボットの操作権を取得する（ロックをかける）
  // ReleaseOperationLock: ロボットの操作権を解放する（ロックを解除する）
  //
  // 例：ユーザー A がロボットを操作中 → ユーザー B は操作できない
  //     ユーザー A がロックを解放 → ユーザー B が操作可能になる
  // -------------------------------------------------------------------------
  // Operation lock management
  rpc AcquireOperationLock(OperationLockRequest) returns (OperationLockResponse);
  rpc ReleaseOperationLock(OperationUnlockRequest) returns (CommandAck);
}

// =============================================================================
// Service Request/Response Messages（リクエスト/レスポンスのメッセージ定義）
// =============================================================================
//
// 【message とは？】
// gRPC で送受信するデータの「型（構造体）」を定義します。
// Python でいう dataclass、TypeScript でいう interface に相当します。
//
// 【フィールド番号（= 1, = 2, ...）とは？】
// 各フィールドには一意の番号が割り当てられます。
// これはバイナリエンコード時の識別子として使われます。
//   - 一度使った番号は変更してはいけません（互換性が壊れる）
//   - 1〜15 は 1 バイト、16〜2047 は 2 バイトで表現される
//   - よく使うフィールドには小さい番号をつけると効率的
//
// 【フィールドの型】
//   string:   文字列（UTF-8）
//   bool:     真偽値（true / false）
//   int32:    32 ビット整数（-2^31 〜 2^31-1）
//   repeated: 配列（リスト）。0 個以上の要素を持てる
// =============================================================================

// ---------------------------------------------------------------------------
// EmergencyStopRequest - 緊急停止リクエスト（特定のロボット向け）
// ---------------------------------------------------------------------------
// 例：
//   {
//     "robot_id": "robot-001",
//     "user_id": "user-123",
//     "reason": "障害物への衝突を回避"
//   }
// ---------------------------------------------------------------------------
message EmergencyStopRequest {
  string robot_id = 1;  // 停止させたいロボットの識別子（例："robot-001"）
  string user_id = 2;   // 停止を指示したユーザーの識別子（監査ログ用）
  string reason = 3;    // 停止理由（あとで原因を調査するために記録する）
}

// ---------------------------------------------------------------------------
// EmergencyStopResponse - 緊急停止レスポンス
// ---------------------------------------------------------------------------
// 停止が成功したかどうかを返します。
// success が false の場合、message にエラー内容が入ります。
// ---------------------------------------------------------------------------
message EmergencyStopResponse {
  bool success = 1;     // true = 停止成功、false = 停止失敗
  string message = 2;   // 結果の詳細メッセージ（例："Robot stopped successfully"）
}

// ---------------------------------------------------------------------------
// EmergencyStopAllRequest - 全ロボット一斉停止リクエスト
// ---------------------------------------------------------------------------
message EmergencyStopAllRequest {
  string user_id = 1;   // 停止を指示したユーザーの識別子
  string reason = 2;    // 一斉停止の理由
}

// ---------------------------------------------------------------------------
// EmergencyStopAllResponse - 全ロボット一斉停止レスポンス
// ---------------------------------------------------------------------------
// robots_stopped: 停止に成功したロボット数
// failed_robot_ids: 停止に失敗したロボットの ID リスト
// 例：10 台中 8 台成功、2 台失敗 → robots_stopped=8, failed_robot_ids=["r-03","r-07"]
// ---------------------------------------------------------------------------
message EmergencyStopAllResponse {
  bool success = 1;                      // 全体として成功したか
  int32 robots_stopped = 2;             // 停止に成功したロボット数
  repeated string failed_robot_ids = 3; // 停止に失敗したロボットの ID 一覧（repeated = 配列）
  string message = 4;                    // 結果の詳細メッセージ
}

// ---------------------------------------------------------------------------
// GetRobotStatusRequest - ロボット状態取得リクエスト
// ---------------------------------------------------------------------------
// robot_id を指定して、そのロボットの状態を問い合わせます。
// ---------------------------------------------------------------------------
message GetRobotStatusRequest {
  string robot_id = 1;  // 状態を取得したいロボットの識別子
}

// ---------------------------------------------------------------------------
// ListConnectedRobotsRequest - 接続中ロボット一覧取得リクエスト
// ---------------------------------------------------------------------------
// フィールドがない空のメッセージです。
// 「引数なしで API を呼ぶ」場合でも、gRPC ではリクエストメッセージが必要です。
// 将来フィルター条件（例：場所、ステータス）を追加する際に拡張できます。
// ---------------------------------------------------------------------------
message ListConnectedRobotsRequest {}

// ---------------------------------------------------------------------------
// ListConnectedRobotsResponse - 接続中ロボット一覧レスポンス
// ---------------------------------------------------------------------------
// repeated キーワード = 配列（リスト）を意味します。
// RobotStatus のリストとして、接続中の全ロボット情報を返します。
// ---------------------------------------------------------------------------
message ListConnectedRobotsResponse {
  repeated RobotStatus robots = 1;  // 接続中ロボットの状態一覧
}

// ---------------------------------------------------------------------------
// StreamSensorDataRequest - センサーデータストリーミングのリクエスト
// ---------------------------------------------------------------------------
// topics で受信したいセンサーの種類を指定します。
// topics が空（指定なし）の場合は、すべてのセンサーデータが送られます。
//
// topics の例:
//   ["lidar"]           → LiDAR データのみ受信
//   ["camera", "imu"]   → カメラと IMU データを受信
//   []                  → すべてのセンサーデータを受信
// ---------------------------------------------------------------------------
message StreamSensorDataRequest {
  string robot_id = 1;          // センサーデータを受信したいロボットの識別子
  repeated string topics = 2;   // Empty = all topics（受信したいトピック一覧）
}
