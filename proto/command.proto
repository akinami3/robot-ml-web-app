// =============================================================================
// command.proto - ロボット制御コマンドのメッセージ定義
// =============================================================================
//
// 【このファイルの目的】
// Webアプリからロボットに送る制御コマンド（指令）を定義します。
// ユーザーの操作（ジョイスティック操作、ナビゲーション目標指定など）が
// ここで定義されたメッセージ形式に変換され、ロボットに送信されます。
//
// 【メッセージの流れ】
// ユーザー操作 → フロントエンド → WebSocket → ゲートウェイ(Go)
//   → gRPC(Protocol Buffers) → バックエンド(Python) → ロボット
//
// =============================================================================

// Protocol Buffers のバージョン指定（proto3は最新の構文バージョン）
syntax = "proto3";

// パッケージ名（名前空間）: 他の.protoファイルと名前の衝突を防ぐ
package robotai;

// Go言語用のパッケージパス指定（Goコード生成時に使用）
option go_package = "github.com/robot-ai-webapp/gateway/internal/bridge/proto";

// 外部.protoファイルのインポート
// google/protobuf/timestamp.proto : 日時型（GoogleのWell-Known Type）
import "google/protobuf/timestamp.proto";
// sensor.proto : 同じプロジェクトのセンサーデータ定義
//   Pose, Twist, BatteryState, Odometry などの型を再利用する
import "sensor.proto";

// =============================================================================
// Robot Command Messages - ロボット制御コマンドのメッセージ
// =============================================================================

// ---------------------------------------------------------------------------
// VelocityCommand - 速度指令コマンド（手動操作用）
// ---------------------------------------------------------------------------
// 【速度指令（Velocity Command）とは？】
// ロボットに「この速度で動け」と指示するコマンド。
// Webアプリのジョイスティック（バーチャルパッド）操作で送信される。
//
// 【差動二輪ロボットの速度制御】
// 差動二輪ロボット（左右の車輪で駆動するタイプ）の場合:
//   linear_x > 0 : 前進
//   linear_x < 0 : 後退
//   angular_z > 0 : 左旋回（反時計回り）
//   angular_z < 0 : 右旋回（時計回り）
//   linear_x + angular_z : 前進しながら旋回（円弧を描く）
//
// 【メカナムホイールロボットの場合】
// 全方向移動可能なロボットは linear_y も使用:
//   linear_y > 0 : 左方向に横移動
//   linear_y < 0 : 右方向に横移動
// ---------------------------------------------------------------------------

// Velocity command (manual control)
// 速度指令（手動操作）
message VelocityCommand {
  // linear_x : 前後方向の速度 [m/s]（正=前進、負=後退）
  double linear_x = 1;
  // linear_y : 左右方向の速度 [m/s]（正=左、負=右）
  //   通常の差動二輪ロボットでは0（横移動不可）
  double linear_y = 2;
  // angular_z : Z軸周りの旋回速度 [rad/s]（正=反時計回り、負=時計回り）
  double angular_z = 3;
}

// ---------------------------------------------------------------------------
// NavigationGoal - ナビゲーション目標（自律移動の目的地）
// ---------------------------------------------------------------------------
// 【自律ナビゲーションとは？】
// ロボットが指定された目的地まで自動で移動する機能。
// 以下のステップで動作:
//   1. ユーザーが地図上で目的地をクリック
//   2. NavigationGoal メッセージが送信される
//   3. ロボットがA*やDWAなどのアルゴリズムで経路を計画
//   4. 障害物を避けながら移動
//   5. 目的地に到達したら停止
//
// 【tolerance（許容誤差）】
// ロボットは完全に正確な位置に停止することは難しい。
// 「この程度の誤差ならOK」という許容範囲を指定する。
// ---------------------------------------------------------------------------

// Navigation goal
// ナビゲーション目標（自律移動の目的地）
message NavigationGoal {
  // goal_pose : 目的地の位置と姿勢
  //   Pose型 = Vector3(位置) + Quaternion(姿勢)
  //   「どこに、どちらを向いて」到着するかを指定
  Pose goal_pose = 1;
  // frame_id : 座標系の名前
  //   "map" : 地図座標系（ほとんどの場合これ）
  //   "base_link" : ロボット相対座標系（「前方に3m」のような指定）
  string frame_id = 2;
  // tolerance_position : 位置の許容誤差 [メートル]
  //   例: 0.1 → 目的地から10cm以内に到達すればOK
  double tolerance_position = 3;
  // tolerance_orientation : 姿勢の許容誤差 [ラジアン]
  //   例: 0.1 → 約5.7度以内の角度ズレならOK
  double tolerance_orientation = 4;
}

// ---------------------------------------------------------------------------
// NavigationCancel - ナビゲーションキャンセル
// ---------------------------------------------------------------------------
// 【キャンセルコマンド】
// 実行中の自律ナビゲーションを中断するコマンド。
// フィールドを持たない空のメッセージ。
// 「このメッセージが送られた」こと自体がキャンセルの合図。
//
// 【空メッセージの使い方】
// Protocol Buffersでは、フィールドのない空のメッセージも定義できる。
// 「アクションの種類」を区別するためだけに使うパターン。
// ---------------------------------------------------------------------------

// Navigation cancel
// ナビゲーションキャンセル
message NavigationCancel {}

// ---------------------------------------------------------------------------
// WaypointNavigation - ウェイポイントナビゲーション（巡回経路）
// ---------------------------------------------------------------------------
// 【ウェイポイントとは？】
// ロボットが順番に通過する中間地点のこと。
// 複数のウェイポイントを指定して「巡回経路」を定義できる。
//
// 【用途の例】
// - 倉庫内の決まった経路を巡回する搬送ロボット
// - 警備ロボットのパトロール経路
// - 農業ロボットの畝に沿った移動
//
// repeated Pose waypoints : ウェイポイントの配列
// repeatedは「0個以上の要素を持つ配列」を意味するProtocol Buffersのキーワード
// ---------------------------------------------------------------------------

// Waypoint navigation
// ウェイポイントナビゲーション（巡回経路）
message WaypointNavigation {
  // waypoints : 巡回するウェイポイント（通過点）のリスト
  //   repeated = 配列。順番に通過する
  repeated Pose waypoints = 1;
  // frame_id : 座標系の名前（通常 "map"）
  string frame_id = 2;
  // loop : ループ（巡回）するかどうか
  //   true = 最後のウェイポイントに到着したら最初に戻って繰り返す
  //   false = 最後のウェイポイントに到着したら停止
  bool loop = 3;
}

// ---------------------------------------------------------------------------
// EmergencyStop - 緊急停止コマンド
// ---------------------------------------------------------------------------
// 【緊急停止（E-Stop）とは？】
// ロボットを即座に停止させる安全機能。
// 物理的なE-Stopボタン（赤い大きなボタン）と同様の機能をソフトウェアで実装。
//
// 【緊急停止の動作】
// activate = true:
//   1. 全モーターを即停止
//   2. ブレーキを作動（あれば）
//   3. ロボットの状態をEMERGENCY_STOPに変更
//   4. 全ての自律動作を中断
// activate = false:
//   1. 緊急停止を解除
//   2. ロボットを通常状態に戻す（ただし即座には動かない）
//
// 【安全に関する注意】
// 実際のロボットでは、ソフトウェアE-Stopだけでなく、
// 物理的なハードウェアE-Stopボタンも必須（安全規格の要件）。
// ---------------------------------------------------------------------------

// Emergency stop
// 緊急停止
message EmergencyStop {
  // activate : 緊急停止の有効/無効
  //   true = 停止（E-Stop作動）
  //   false = 解除（E-Stop解除）
  bool activate = 1;  // true = stop, false = release
  // reason : 緊急停止の理由（ログに記録）
  //   例: "obstacle detected", "user initiated", "battery critical"
  string reason = 2;
}

// =============================================================================
// Command Envelope - コマンドエンベロープ（封筒）
// =============================================================================
// 【エンベロープパターン】
// 全てのコマンドを1つの共通形式で包む設計パターン。
// 「封筒」にメタデータ（宛先、送信者、ID）を書き、中に「手紙」（コマンド本体）を入れる。
//
// 利点:
//   - 共通のメタデータ（robot_id, user_id, timestamp）を統一管理
//   - 新しいコマンドタイプの追加が容易（oneofに追加するだけ）
//   - ルーティング（どのロボットに送るか）が容易
//   - ログ記録が容易（command_idで追跡）
// =============================================================================

message RobotCommand {
  // robot_id : コマンドの宛先ロボットのID
  string robot_id = 1;
  // user_id : コマンドを送信したユーザーのID（権限チェックに使用）
  string user_id = 2;
  // command_id : コマンドの一意なID（UUID）
  //   コマンドの追跡・重複排除・ACK対応に使用
  string command_id = 3;
  // timestamp : コマンド送信日時
  google.protobuf.Timestamp timestamp = 4;

  // command : コマンド本体（以下のどれか1つ）
  // oneof : 「このうちどれか1つだけ値を持つ」制約
  oneof command {
    VelocityCommand velocity = 10;                // 速度指令（手動操作）
    NavigationGoal navigation_goal = 11;           // ナビゲーション目標
    NavigationCancel navigation_cancel = 12;       // ナビゲーションキャンセル
    WaypointNavigation waypoint_navigation = 13;   // ウェイポイント巡回
    EmergencyStop emergency_stop = 14;             // 緊急停止
  }
}

// ---------------------------------------------------------------------------
// CommandAck - コマンド確認応答（アクノレッジメント）
// ---------------------------------------------------------------------------
// 【ACK（アック）とは？】
// Acknowledgement（確認応答）の略。
// コマンドを受信したロボットが「受け取ったよ、結果はこうだよ」と返すメッセージ。
//
// 【なぜACKが必要？】
// ネットワーク通信では、メッセージが届いたかどうかわからない。
// ACKを使って:
//   1. コマンドが届いたことを確認
//   2. コマンドが成功したか失敗したかを確認
//   3. 失敗した場合はエラーメッセージを確認
// ---------------------------------------------------------------------------

// Command acknowledgement
// コマンド確認応答
message CommandAck {
  // command_id : 対応するコマンドのID（どのコマンドへの応答か）
  string command_id = 1;
  // robot_id : 応答したロボットのID
  string robot_id = 2;
  // success : コマンドの実行結果
  //   true = 成功（コマンドが受理・実行された）
  //   false = 失敗（エラーが発生した）
  bool success = 3;
  // error_message : エラー時のメッセージ（成功時は空文字列）
  //   例: "Navigation goal is outside map bounds"
  string error_message = 4;
  // timestamp : 応答の日時
  google.protobuf.Timestamp timestamp = 5;
}

// =============================================================================
// Robot Status - ロボットの状態
// =============================================================================

// ---------------------------------------------------------------------------
// RobotState - ロボットの状態を表す列挙型（Enum）
// ---------------------------------------------------------------------------
// 【enum（列挙型）とは？】
// 値の取りうる範囲を名前付きで限定する型。
// 「状態」のように決まった選択肢があるデータに最適。
//
// 【Protocol Buffersのenum ルール】
// 1. 最初の値は必ず 0 にする（デフォルト値として使用される）
// 2. 値には意味のあるプレフィックスをつける（ROBOT_STATE_xxx）
//    → 異なるenumの値が衝突しないようにするため
// 3. 0番目の値は規約として UNKNOWN や UNSPECIFIED にする
//    → デフォルト値（未設定）を明示的に区別するため
// ---------------------------------------------------------------------------

enum RobotState {
  ROBOT_STATE_UNKNOWN = 0;          // 不明（デフォルト値/初期値）
  ROBOT_STATE_IDLE = 1;             // アイドル（待機中。コマンド受付可能）
  ROBOT_STATE_MANUAL_CONTROL = 2;   // 手動操作中（ユーザーがジョイスティックで操作中）
  ROBOT_STATE_NAVIGATING = 3;       // 自律ナビゲーション中（目的地に向かって移動中）
  ROBOT_STATE_EMERGENCY_STOP = 4;   // 緊急停止中（全モーター停止）
  ROBOT_STATE_ERROR = 5;            // エラー状態（異常が発生）
  ROBOT_STATE_DISCONNECTED = 6;     // 切断（ロボットと通信できない）
}

// ---------------------------------------------------------------------------
// RobotStatus - ロボットの現在状態
// ---------------------------------------------------------------------------
// 【ロボットのステータス情報】
// ロボットが定期的（例: 1秒ごと）にこのメッセージを送信し、
// Webアプリのダッシュボードに表示される。
//
// 【map<string, string>とは？】
// キーと値のペアの集合（辞書/マップ）。
// Protocol Buffersの組み込み型で、柔軟な追加情報の格納に使える。
// 例: {"firmware_version": "2.1.0", "model": "TurtleBot3"}
// ---------------------------------------------------------------------------

message RobotStatus {
  // robot_id : ロボットのID
  string robot_id = 1;
  // state : ロボットの現在の状態（上のRobotState enumの値）
  RobotState state = 2;
  // battery : バッテリーの状態（sensor.protoのBatteryState型を再利用）
  BatteryState battery = 3;
  // current_pose : 現在の位置と速度（sensor.protoのOdometry型を再利用）
  Odometry current_pose = 4;
  // active_user_id : 現在操作ロックを持っているユーザーのID
  //   ロボットを同時に複数人が操作しないための制御
  string active_user_id = 5;  // Who has operation lock
  // estop_active : 緊急停止が作動中かどうか
  bool estop_active = 6;
  // timestamp : このステータスの送信日時
  google.protobuf.Timestamp timestamp = 7;
  // metadata : 追加のメタデータ（キー・バリュー形式）
  //   map<キーの型, 値の型> : 辞書型
  //   拡張性のために用意。自由に情報を追加できる
  map<string, string> metadata = 8;
}

// =============================================================================
// Operation Lock - 操作ロック
// =============================================================================
// 【操作ロックとは？】
// 同じロボットを複数のユーザーが同時に操作すると危険なため、
// 「ロック」の仕組みで排他制御する。
//
// 【排他制御（Exclusive Control）】
//   1. ユーザーAがロボットのロックを取得 → 操作権限を獲得
//   2. ユーザーBがロックを要求 → 「ユーザーAが操作中です」と拒否
//   3. ユーザーAがロックを解放 → 他のユーザーが取得可能に
//
// 【有効期限（expires_at）】
// ロックには有効期限を設ける（例: 5分）。
// なぜ？ → ユーザーが解放を忘れたり、ブラウザがクラッシュした場合に
//           ロックが永遠に残ってしまうのを防ぐため。
// 有効期限内にロックを更新（延長）しないと自動解放される。
// =============================================================================

// 操作ロック取得リクエスト
message OperationLockRequest {
  // robot_id : ロックを取得したいロボットのID
  string robot_id = 1;
  // user_id : ロックを要求するユーザーのID
  string user_id = 2;
}

// 操作ロック取得レスポンス
message OperationLockResponse {
  // granted : ロックが取得できたかどうか
  //   true = ロック取得成功
  //   false = ロック取得失敗（他のユーザーが使用中）
  bool granted = 1;
  // locked_by_user_id : 現在ロックを保持しているユーザーのID
  //   ロック取得失敗時に「誰が使っているか」を表示するために使う
  string locked_by_user_id = 2;
  // expires_at : ロックの有効期限
  //   この日時を過ぎるとロックは自動解放される
  google.protobuf.Timestamp expires_at = 3;
  // message : 人間向けのメッセージ
  //   例: "Lock acquired successfully" / "Robot is currently locked by user xyz"
  string message = 4;
}

// 操作ロック解放リクエスト
message OperationUnlockRequest {
  // robot_id : ロックを解放するロボットのID
  string robot_id = 1;
  // user_id : ロックを解放するユーザーのID（本人確認に使用）
  string user_id = 2;
}
