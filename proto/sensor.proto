// =============================================================================
// sensor.proto - センサーデータのメッセージ定義
// =============================================================================
//
// 【Protocol Buffers（プロトコルバッファ）の基本】
//
// .protoファイルとは？
//   データの構造を定義するファイル。JSONのスキーマのようなもの。
//   ここで定義した構造から、Python・Go・Java等のコードが自動生成される。
//
// 【なぜProtocol Buffersを使うの？】
//   - JSONと比べて5-10倍高速にシリアライズ（データ変換）できる
//   - データサイズがJSONの1/3-1/10
//   - 型安全: コンパイル時にデータの型をチェック
//   - ロボットのセンサーデータは高頻度（100Hzなど）で送られるため、
//     効率的なデータ形式が必要
//
// =============================================================================

// syntax = "proto3" : Protocol Buffersのバージョン指定
// proto3は最新の構文バージョン（proto2は旧バージョン）
// proto3の特徴:
//   - フィールドはデフォルトでoptional（省略可能）
//   - デフォルト値が自動設定（数値=0, 文字列=""、bool=false）
//   - required/optionalキーワードが廃止（シンプルに）
syntax = "proto3";

// package : パッケージ名（名前空間）。メッセージ名の衝突を防ぐ
// 例: robotai.SensorHeader と other.SensorHeader を区別できる
package robotai;

// option go_package : Go言語用のパッケージパス指定
// Goのコード生成時に、このパッケージパスが使われる
// Go言語ではパッケージのインポートにフルパスを使う慣例がある
option go_package = "github.com/robot-ai-webapp/gateway/internal/bridge/proto";

// import : 他のprotoファイルやGoogleの標準型をインポート
// google/protobuf/timestamp.proto : 日時（タイムスタンプ）型の定義
// この型はGoogleが提供する「Well-Known Types」の一つ
// 他にも Duration（期間）、Empty（空）、Any（任意型）などがある
import "google/protobuf/timestamp.proto";

// =============================================================================
// Sensor Data Messages
// センサーデータのメッセージ定義
// =============================================================================

// ---------------------------------------------------------------------------
// SensorHeader - 全センサーメッセージに共通するヘッダー情報
// ---------------------------------------------------------------------------
// 【message（メッセージ）とは？】
// データ構造を定義するキーワード。
// プログラミング言語の「クラス」や「構造体」に相当する。
// messageの中にフィールド（データ項目）を定義する。
//
// 【フィールド番号（= 1, = 2, ...）とは？】
// 各フィールドに一意の番号を割り当てる。Protocol Buffersの核心的な仕組み。
// バイナリエンコード時に、フィールド名ではなくこの番号でデータを識別する。
// → 番号はデータの互換性に直結するため、一度使った番号は変更・再利用してはいけない
//
// 【フィールド番号のベストプラクティス】
// 1-15 : よく使うフィールドに割り当て（1バイトでエンコードされるため効率的）
// 16-2047 : 2バイト必要だが、通常のフィールドに十分
// 19000-19999 : 予約済み（使用不可）
//
// 【よく使うデータ型】
// string : 文字列（UTF-8）
// int32/int64 : 整数（32/64ビット）
// float/double : 浮動小数点（32/64ビット）
// bool : 真偽値
// bytes : バイト列（バイナリデータ）
// uint32/uint64 : 符号なし整数（0以上のみ）
// ---------------------------------------------------------------------------

// Common header for all sensor messages
// 全センサーメッセージに共通するヘッダー
message SensorHeader {
  // robot_id : このセンサーデータを送信したロボットのID
  string robot_id = 1;
  // topic : データの種類を示すトピック名（ROSのトピック名に対応）
  //   例: "/scan", "/odom", "/imu/data"
  string topic = 2;
  // frame_id : 座標系（フレーム）の名前
  //   例: "base_link"（ロボットの中心）, "laser"（LiDARの位置）
  //   ロボットは複数の座標系を持ち、TF（Transform）で変換する
  string frame_id = 3;
  // timestamp : データが取得された日時（マイクロ秒精度）
  google.protobuf.Timestamp timestamp = 4;
  // sequence : シーケンス番号（連番）。データの欠落を検出するために使用
  uint64 sequence = 5;
}

// ---------------------------------------------------------------------------
// LaserScan - 2D LiDARスキャンデータ
// ---------------------------------------------------------------------------
// 【LiDAR（ライダー）とは？】
// Light Detection And Ranging の略。レーザー光で周囲の距離を測定するセンサー。
//
// 【動作原理】
// 1. レーザー光を照射
// 2. 物体に反射して戻ってくるまでの時間を計測
// 3. 光速 × 時間 ÷ 2 = 距離 を計算
// 4. レーザーを回転させて360度スキャン → 周囲の形状を取得
//
// 【2D LiDAR vs 3D LiDAR】
// 2D LiDAR : 水平面のみスキャン。安価。主に自己位置推定・障害物回避に使用
// 3D LiDAR : 上下にもスキャン。高価。自動運転車などで使用
//
// 【このデータの使い道】
// - SLAM（自己位置推定と地図作成）
// - 障害物検知・回避
// - 環境マッピング
//
// 【repeated（リピーテッド）とは？】
// 配列（リスト）を表すキーワード。0個以上の要素を持てる。
// 例: repeated float ranges = 9; → [1.5, 2.3, 0.8, ...] のような距離データの配列
// ---------------------------------------------------------------------------

// 2D LiDAR scan
// 2Dライダーのスキャンデータ
message LaserScan {
  // ヘッダー（ロボットID、タイムスタンプなど共通情報）
  SensorHeader header = 1;
  // angle_min : スキャン開始角度[ラジアン]（通常 -π ≈ -3.14）
  float angle_min = 2;
  // angle_max : スキャン終了角度[ラジアン]（通常 +π ≈ +3.14）
  float angle_max = 3;
  // angle_increment : 各レーザー光線間の角度[ラジアン]
  //   例: 0.0175 rad ≈ 1度 → 360本のレーザー光線
  float angle_increment = 4;
  // time_increment : 各測定間の時間[秒]
  float time_increment = 5;
  // scan_time : 1回の全スキャンにかかる時間[秒]
  float scan_time = 6;
  // range_min : 測定可能な最小距離[メートル]（これより近いと測定不能）
  float range_min = 7;
  // range_max : 測定可能な最大距離[メートル]（これより遠いと測定不能）
  float range_max = 8;
  // ranges : 各角度での測定距離[メートル]の配列
  //   配列の長さ = (angle_max - angle_min) / angle_increment
  //   値がrange_min〜range_maxの範囲外なら、その方向に物体がないことを意味
  repeated float ranges = 9;
  // intensities : 各角度での反射強度の配列（オプション）
  //   反射強度 = 反射した光の強さ。物体の素材を推測するのに使える
  repeated float intensities = 10;
}

// ---------------------------------------------------------------------------
// PointCloud - 3Dポイントクラウド（点群）データ
// ---------------------------------------------------------------------------
// 【ポイントクラウド（点群）とは？】
// 3D空間上の点の集合。各点は (x, y, z) 座標と追加情報（色、強度など）を持つ。
// 3D LiDARやデプスカメラ（深度カメラ）で取得される。
//
// 【用途】
// - 3Dマッピング（建物や環境の3Dモデル作成）
// - 物体認識（3D空間で物体を検出）
// - 自動運転（周囲の3D環境を把握）
// ---------------------------------------------------------------------------

// 3D Point Cloud
// 3Dポイントクラウド（点群）
message PointCloud {
  SensorHeader header = 1;
  // width : 点群データの幅（非整列データの場合は総点数）
  uint32 width = 2;
  // height : 点群データの高さ（非整列データの場合は1）
  //   width × height = 総点数
  uint32 height = 3;
  // fields : 各点が持つデータフィールドの定義
  //   例: x(float), y(float), z(float), rgb(uint32)
  //   repeated = 配列。複数のフィールド定義を持つ
  repeated PointField fields = 4;
  // is_bigendian : バイトオーダー（CPUのアーキテクチャ依存）
  //   false = リトルエンディアン（x86/ARM = ほとんどのPC/ロボット）
  bool is_bigendian = 5;
  // point_step : 1点あたりのバイト数
  uint32 point_step = 6;
  // row_step : 1行あたりのバイト数
  uint32 row_step = 7;
  // data : 実際の点群データ（バイナリ形式）
  //   bytes型: 任意のバイナリデータを格納できる
  bytes data = 8;
  // is_dense : 全点が有効値かどうか（NaN/Infがない = true）
  bool is_dense = 9;
}

// PointField - ポイントクラウドの各フィールドの定義
// 各点がどんなデータを持つかを定義する
message PointField {
  // name : フィールド名（例: "x", "y", "z", "rgb", "intensity"）
  string name = 1;
  // offset : データ内でのバイトオフセット（開始位置）
  uint32 offset = 2;
  // datatype : データ型（1=INT8, 2=UINT8, ..., 7=FLOAT32, 8=FLOAT64）
  uint32 datatype = 3;
  // count : このフィールドの要素数（通常は1）
  uint32 count = 4;
}

// ---------------------------------------------------------------------------
// Imu - IMU（慣性計測装置）のデータ
// ---------------------------------------------------------------------------
// 【IMU（Inertial Measurement Unit）とは？】
// ロボットの動きと姿勢を計測するセンサー。以下の3つのセンサーを統合:
//
// 1. 加速度センサー（Accelerometer）
//    - 3軸(X,Y,Z)の加速度を測定 [m/s²]
//    - 重力加速度（9.8 m/s²）も検出するため、傾きの推定にも使える
//
// 2. ジャイロスコープ（Gyroscope）
//    - 3軸(X,Y,Z)の角速度を測定 [rad/s]
//    - ロボットがどれだけ回転しているかを検出
//
// 3. 地磁気センサー（Magnetometer）（搭載していないIMUもある）
//    - 磁北の方向を検出（コンパスの役割）
//
// 【IMUの用途】
// - 姿勢推定: ロボットが何度傾いているか（ロール、ピッチ、ヨー）
// - 自己位置推定: オドメトリと組み合わせて精度を向上
// - 振動検知: 異常振動の検出
// ---------------------------------------------------------------------------

// IMU data
// IMU（慣性計測装置）データ
message Imu {
  SensorHeader header = 1;
  // orientation : 姿勢（クォータニオン表現）
  //   → Quaternionメッセージを参照
  Quaternion orientation = 2;
  // orientation_covariance : 姿勢の共分散行列（3x3 = 9要素）
  //   → 共分散についてはOdometryの説明を参照
  //   repeated double = double型の配列
  repeated double orientation_covariance = 3;
  // angular_velocity : 3軸の角速度 [rad/s]
  //   ロボットがどの軸周りにどれだけ速く回転しているか
  Vector3 angular_velocity = 4;
  // angular_velocity_covariance : 角速度の共分散行列（3x3 = 9要素）
  repeated double angular_velocity_covariance = 5;
  // linear_acceleration : 3軸の加速度 [m/s²]
  //   重力加速度を含む。静止時でもZ軸に約9.8 m/s²が検出される
  Vector3 linear_acceleration = 6;
  // linear_acceleration_covariance : 加速度の共分散行列（3x3 = 9要素）
  repeated double linear_acceleration_covariance = 7;
}

// ---------------------------------------------------------------------------
// CompressedImage - カメラ画像データ（圧縮済み）
// ---------------------------------------------------------------------------
// 【なぜ画像を圧縮して送る？】
// 生画像（RAW）はデータ量が非常に大きい:
//   640×480 RGB画像 = 640 × 480 × 3 = 約921KB
//   JPEG圧縮すると = 約50-100KB（約1/10-1/20）
// ネットワーク帯域の節約のため、圧縮して送るのが一般的。
// ---------------------------------------------------------------------------

// Camera image (compressed)
// カメラ画像（圧縮済み）
message CompressedImage {
  SensorHeader header = 1;
  // format : 画像フォーマット（"jpeg", "png"）
  //   JPEG: 高圧縮、非可逆圧縮（画質がやや劣化）。写真向き
  //   PNG: 可逆圧縮（画質劣化なし）。圧縮率は低い。図面やスクリーンショット向き
  string format = 2;  // jpeg, png
  // data : 圧縮済み画像のバイナリデータ
  bytes data = 3;
}

// ---------------------------------------------------------------------------
// Odometry - オドメトリ（走行距離計測）データ
// ---------------------------------------------------------------------------
// 【オドメトリとは？】
// ロボットの位置と速度を推定するデータ。
// 車輪の回転数やIMUから計算される。
//
// 例: 左車輪が10回転、右車輪が10回転 → 直進した距離を計算
//     左車輪が10回転、右車輪が5回転 → 右に曲がったことを計算
//
// 【注意：オドメトリの誤差蓄積】
// オドメトリは車輪の滑り等で誤差が蓄積される（ドリフト）。
// 長距離走行すると、実際の位置とオドメトリが大きくずれることがある。
// → LiDARやGPSと組み合わせて補正する（センサーフュージョン）
//
// 【共分散（Covariance）とは？】
// 測定値の不確実性（誤差の大きさと相関）を表す行列。
// 共分散行列が大きい = 測定値の信頼度が低い
// 例: GPSは水平方向は精度が高いが、垂直方向は精度が低い
//     → covarianceで軸ごとの不確実性を表現
//
// 6×6共分散行列（36要素）:
// [x, y, z, roll, pitch, yaw] の各ペアの相関を表す
// ---------------------------------------------------------------------------

// Odometry
// オドメトリ（走行距離計測）
message Odometry {
  SensorHeader header = 1;
  // child_frame_id : 子座標系の名前
  //   通常 "base_link"（ロボット本体の座標系）
  string child_frame_id = 2;
  // pose : 位置と姿勢（Poseメッセージ = 位置Vector3 + 姿勢Quaternion）
  Pose pose = 3;
  // pose_covariance : 位置の共分散行列（6x6 = 36要素）
  //   推定位置の信頼度。値が大きいほど不確実
  repeated double pose_covariance = 4;
  // twist : 速度（線速度 + 角速度）
  Twist twist = 5;
  // twist_covariance : 速度の共分散行列（6x6 = 36要素）
  repeated double twist_covariance = 6;
}

// ---------------------------------------------------------------------------
// BatteryState - バッテリー（電池）状態
// ---------------------------------------------------------------------------
// 【ロボットのバッテリー管理】
// バッテリー残量の監視は非常に重要:
//   - 残量が少ない場合、自動で充電ステーションに戻る
//   - 電圧が低下すると、モーターの出力が落ちる
//   - 過放電はバッテリーの寿命を縮める
// ---------------------------------------------------------------------------

// Battery status
// バッテリー状態
message BatteryState {
  SensorHeader header = 1;
  // voltage : 電圧 [V]（ボルト）
  //   例: 12.6V（満充電）→ 10.8V（放電終了）
  float voltage = 2;
  // current : 電流 [A]（アンペア）
  //   正の値 = 充電中、負の値 = 放電中（電力消費中）
  float current = 3;
  // charge : 現在の充電量 [Ah]（アンペアアワー）
  float charge = 4;
  // capacity : バッテリーの最大容量 [Ah]
  float capacity = 5;
  // percentage : 残量のパーセンテージ [0.0 ~ 1.0]
  //   0.0 = 0%（空）、1.0 = 100%（満充電）
  float percentage = 6;
  // power_supply_status : 電源の状態コード
  //   0=不明, 1=充電中, 2=放電中, 3=未充電, 4=満充電
  uint32 power_supply_status = 7;
}

// ---------------------------------------------------------------------------
// NavSatFix - GPS（衛星測位）データ
// ---------------------------------------------------------------------------
// 【GPS（Global Positioning System）とは？】
// 人工衛星からの信号を受信して、地球上の位置を特定するシステム。
// 精度: 民生用で3-5m程度。RTK-GPSなら数cm精度。
//
// 【座標系】
// 緯度（latitude）: 赤道を0度として、北が+、南が- （-90〜+90度）
// 経度（longitude）: 本初子午線(グリニッジ)を0度として、東が+、西が- （-180〜+180度）
// 高度（altitude）: 海面（楕円体面）からの高さ [メートル]
//
// 【ロボットでの用途】
// - 屋外ロボットの位置特定
// - 地図上での表示
// - 広域ナビゲーション
// ※ 屋内では衛星信号が届かないため使用不可
// ---------------------------------------------------------------------------

// GPS
// GPS（衛星測位）
message NavSatFix {
  SensorHeader header = 1;
  // latitude : 緯度 [度]
  //   例: 35.6812 = 東京都千代田区（北緯35.6812度）
  double latitude = 2;
  // longitude : 経度 [度]
  //   例: 139.7671 = 東京都千代田区（東経139.7671度）
  double longitude = 3;
  // altitude : 高度 [メートル]
  double altitude = 4;
  // position_covariance : 位置の共分散行列（3x3 = 9要素）
  //   [東方向, 北方向, 上方向] の不確実性
  repeated double position_covariance = 5;
  // position_covariance_type : 共分散のタイプ
  //   0=不明, 1=近似, 2=対角（各軸独立）, 3=既知
  uint32 position_covariance_type = 6;
}

// =============================================================================
// Geometry Types - 幾何学的な基本型
// =============================================================================
// ロボット工学で頻繁に使われる3D空間の基本的なデータ型を定義
// =============================================================================

// ---------------------------------------------------------------------------
// Vector3 - 3次元ベクトル
// ---------------------------------------------------------------------------
// 【3Dベクトルとは？】
// 3つの数値(x, y, z)で3D空間の方向と大きさを表す。
// 用途:
//   - 位置: (x=1.0, y=2.0, z=0.0) → 座標(1, 2, 0)の位置
//   - 速度: (x=0.5, y=0.0, z=0.0) → X方向に0.5 m/sで移動
//   - 力: (x=0.0, y=0.0, z=-9.8) → 重力（Z方向に-9.8 m/s²）
//
// 【ロボットの座標系の慣例（REP103）】
//   X軸 : 前方向（ロボットの前方が正）
//   Y軸 : 左方向（ロボットの左が正）
//   Z軸 : 上方向（空に向かうのが正）
// ---------------------------------------------------------------------------

message Vector3 {
  double x = 1;
  double y = 2;
  double z = 3;
}

// ---------------------------------------------------------------------------
// Quaternion - クォータニオン（四元数）
// ---------------------------------------------------------------------------
// 【クォータニオン（四元数）とは？】
// 3D空間での回転（姿勢）を表現する数学的手法。
// 4つの数値 (x, y, z, w) で回転を表す。
//
// 【なぜオイラー角（ロール・ピッチ・ヨー）ではなくクォータニオン？】
// オイラー角の問題「ジンバルロック」:
//   特定の角度（例: ピッチ=90度）で回転の自由度が1つ失われる現象
//   → 計算が不正確になる
// クォータニオンはジンバルロックが起きない:
//   - 数学的に安定
//   - 回転の補間（滑らかなアニメーション）が簡単
//   - 計算コストも低い
//
// 【値の意味】
// 単位クォータニオン: x²+y²+z²+w² = 1 を満たす
// 回転なし（単位元）: (x=0, y=0, z=0, w=1)
// Z軸周り90度回転: (x=0, y=0, z=0.707, w=0.707)
//
// 直感的な理解:
//   (x, y, z) = 回転軸の方向（正規化ベクトル × sin(θ/2)）
//   w = cos(θ/2)   ここで θ は回転角
// ---------------------------------------------------------------------------

message Quaternion {
  double x = 1;
  double y = 2;
  double z = 3;
  double w = 4;
}

// ---------------------------------------------------------------------------
// Pose - 位置と姿勢（ポーズ）
// ---------------------------------------------------------------------------
// 【Poseとは？】
// ロボットの「位置」（どこにいるか）と「姿勢」（どちらを向いているか）
// を合わせたもの。ロボット工学では最も基本的な概念の1つ。
//
// 例: ロボットが座標(3.0, 2.0, 0.0)にいて、北を向いている
//   position = {x: 3.0, y: 2.0, z: 0.0}
//   orientation = {x: 0, y: 0, z: 0.707, w: 0.707}  // 90度回転
// ---------------------------------------------------------------------------

message Pose {
  // position : 位置（3D空間の座標）
  Vector3 position = 1;
  // orientation : 姿勢（クォータニオンで表現した回転）
  Quaternion orientation = 2;
}

// ---------------------------------------------------------------------------
// Twist - 速度（線速度と角速度）
// ---------------------------------------------------------------------------
// 【Twistとは？】
// ロボットの「移動速度」と「回転速度」を表す。
// ロボットを動かすCMD_VEL（速度指令）にもよく使われる。
//
// linear（線速度）: 直線方向の速度 [m/s]
//   例: linear.x = 0.5 → 前方に0.5 m/sで移動
// angular（角速度）: 回転方向の速度 [rad/s]
//   例: angular.z = 1.0 → 反時計回りに1.0 rad/sで旋回
//
// 【差動二輪ロボットの場合】
// linear.x と angular.z だけ使用（他は0）:
//   linear.x > 0 : 前進
//   linear.x < 0 : 後退
//   angular.z > 0 : 左旋回（反時計回り）
//   angular.z < 0 : 右旋回（時計回り）
// ---------------------------------------------------------------------------

message Twist {
  // linear : 線速度（並進速度）[m/s]
  Vector3 linear = 1;
  // angular : 角速度（回転速度）[rad/s]
  Vector3 angular = 2;
}

// =============================================================================
// Unified Sensor Data Envelope - 統一センサーデータ封筒
// =============================================================================
// 【エンベロープ（封筒）パターンとは？】
// 異なる種類のデータを1つの共通フォーマットで包む設計パターン。
// 手紙を封筒に入れるように、様々なセンサーデータを統一形式で扱える。
//
// 【oneofとは？】
// 「このフィールドのうち、どれか1つだけ値を持つ」ことを表す。
// union型（共用体）と同じ概念。メモリ効率が良い。
// 例: SensorDataは laser_scan か imu か odometry のどれか1つのデータを持つ
//     同時に2つ以上のデータを持つことはない
//
// 【フィールド番号が10から始まる理由】
// header(=1) と oneofフィールドの間に将来フィールドを追加できるようにするため。
// Protocol Buffersでは互換性のためにフィールド番号の空きを残しておくのが良い慣例。
// =============================================================================

message SensorData {
  // 共通ヘッダー（どのセンサーデータでも必ず含まれる）
  SensorHeader header = 1;
  // data : センサーデータ本体（以下のどれか1つ）
  oneof data {
    LaserScan laser_scan = 10;           // 2D LiDARスキャン
    PointCloud point_cloud = 11;          // 3Dポイントクラウド
    Imu imu = 12;                         // IMU（慣性計測装置）
    CompressedImage compressed_image = 13; // カメラ画像（圧縮済み）
    Odometry odometry = 14;               // オドメトリ（走行距離計測）
    BatteryState battery_state = 15;      // バッテリー状態
    NavSatFix nav_sat_fix = 16;           // GPS位置データ
  }
}

// ---------------------------------------------------------------------------
// SensorDataBatch - センサーデータのバッチ（一括送信）
// ---------------------------------------------------------------------------
// 【なぜバッチ送信？】
// ネットワーク通信ではヘッダーのオーバーヘッドがある。
// 1つずつ送るより、まとめて送った方が効率的。
// 例: 10個のセンサーデータを1回の通信で送信
//
// repeated : 配列（0個以上のSensorData要素を持つリスト）
// ---------------------------------------------------------------------------

// Batch of sensor data
// センサーデータのバッチ（一括送信）
message SensorDataBatch {
  repeated SensorData items = 1;
}
