#!/usr/bin/env bash
# =============================================================================
# Dev Script - Start development environment
# 開発スクリプト - 開発環境を起動するためのスクリプト
# =============================================================================
#
# 【このスクリプトの目的】
# ロボットAI Webアプリの開発環境をワンコマンドで起動します。
# Docker Composeを使って、フロントエンド・バックエンド・ゲートウェイなど
# 複数のサービスをまとめて立ち上げます。
#
# 【使い方】
# ターミナルで以下を実行:
#   ./scripts/dev.sh
#
# 【初心者向け: シェルスクリプトの基本】
# - #!/usr/bin/env bash : シバン（shebang）行。このファイルをbashで実行する指定
# - bash : Linux/macOSの標準的なシェル（コマンドインタープリター）
# - env bash : 環境変数PATHからbashを探して実行する（移植性が高い書き方）
# =============================================================================

# -----------------------------------------------------------------------------
# set -euo pipefail の解説（シェルスクリプトの安全装置）
# -----------------------------------------------------------------------------
# set -e : コマンドがエラー（終了コード≠0）になったら、即座にスクリプトを停止
#           例: docker composeが失敗したら、そこで処理を中断
# set -u : 未定義の変数を使おうとしたらエラーにする
#           例: $TYPO_VAR のようなタイプミスを検出できる
# set -o pipefail : パイプライン（cmd1 | cmd2）でどこかが失敗したらエラーにする
#           例: grep "x" file | wc -l で、grepが失敗してもwcは成功するが、
#               pipefailがあればパイプライン全体をエラーとして扱う
#
# 【なぜこの3つを設定するの？】
# シェルスクリプトはデフォルトでエラーを無視して処理を続けてしまいます。
# これは危険なので、この3つの設定で「何か問題があったら即停止」にしています。
# プロフェッショナルなシェルスクリプトではほぼ必須の設定です。
# -----------------------------------------------------------------------------
set -euo pipefail

# -----------------------------------------------------------------------------
# スクリプトのディレクトリとプロジェクトルートの取得
# -----------------------------------------------------------------------------
# ${BASH_SOURCE[0]} : 現在実行中のスクリプトファイルのパス
#   例: ./scripts/dev.sh や /home/user/project/scripts/dev.sh
#
# dirname : パスからディレクトリ部分だけを取り出すコマンド
#   例: dirname "/home/user/scripts/dev.sh" → "/home/user/scripts"
#
# cd ... && pwd : そのディレクトリに移動してフルパスを取得
#   例: cd "./scripts" && pwd → "/home/user/project/scripts"
#
# $(...) : コマンド置換。コマンドの出力結果を変数に代入できる
#   例: RESULT=$(echo "hello") → RESULT="hello"
#
# 【なぜこんな複雑なことをするの？】
# スクリプトがどこから実行されても（cd先が違っても）、
# 正しいプロジェクトディレクトリを特定するためです。
# 例えば /tmp/ からでも ~/project/ からでも同じ動作になります。
# -----------------------------------------------------------------------------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# SCRIPT_DIR の親ディレクトリ = プロジェクトルート
# 例: /home/user/project/scripts → /home/user/project
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# プロジェクトルートに移動（以降のコマンドはここを基準に実行）
cd "$PROJECT_DIR"

echo "=== Starting Development Environment ==="

# -----------------------------------------------------------------------------
# .envファイルの存在チェックと初期セットアップ
# -----------------------------------------------------------------------------
# [ ! -f .env ] : .envファイルが存在しない場合にtrue
#   -f : ファイルが存在するかチェック（ディレクトリではなくファイル）
#   !  : 否定（存在しない場合にtrue）
#
# 【.envファイルとは？】
# 環境変数（パスワード、APIキー、設定値など）を保存するファイル。
# Gitには含めず（.gitignoreに記載）、各開発者が自分の環境に合わせて設定します。
# Docker Composeは自動的に.envファイルを読み込みます。
#
# 【初回起動時の流れ】
# 1. .envが未作成 → setup.shを実行して初期設定
# 2. setup.shが.env.exampleから.envをコピー
# 3. 開発者がパスワードなどを編集
# -----------------------------------------------------------------------------
if [ ! -f .env ]; then
    echo "Running initial setup..."
    # $SCRIPT_DIR/setup.sh : セットアップスクリプトをフルパスで呼び出し
    # フルパスを使うことで、カレントディレクトリに依存しない
    "$SCRIPT_DIR/setup.sh"
fi

# -----------------------------------------------------------------------------
# Docker Composeでサービスを起動
# -----------------------------------------------------------------------------
# docker compose : Dockerコンテナをまとめて管理するツール
#
# -f docker-compose.yml : ベースとなる設定ファイル（本番共通の定義）
# -f docker-compose.dev.yml : 開発用の上書き設定ファイル
#   → 2つのファイルがマージされる（開発用の設定が優先）
#   → 例: 本番ではポートを公開しないが、開発では公開する
#
# up : コンテナを起動するサブコマンド
# -d : デタッチモード（バックグラウンドで実行）
#       ターミナルが占有されず、他のコマンドを入力できる
# --build : 起動前にDockerイメージを再ビルド
#           コード変更を反映するために必要
#
# 【Docker Composeの仕組み】
# 1つのアプリを複数のコンテナ（フロントエンド、バックエンド、DB等）で構成
# docker-compose.ymlに各サービスの設定を書く
# `docker compose up` 一発で全サービスが起動する
# -----------------------------------------------------------------------------
docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d --build

# -----------------------------------------------------------------------------
# 起動後の情報表示
# -----------------------------------------------------------------------------
# 各サービスのURLを表示して、開発者がアクセスしやすくする
echo ""
echo "=== Services Started ==="
echo "  Frontend:  http://localhost:5173 (dev) / http://localhost:3000"
# ↑ フロントエンド: Vite開発サーバー（ホットリロード対応）ポート5173
#   本番ビルド時はポート3000
echo "  Backend:   http://localhost:8000"
# ↑ バックエンド: FastAPI（PythonのWebフレームワーク）ポート8000
echo "  Swagger:   http://localhost:8000/docs"
# ↑ Swagger UI: APIドキュメント。ブラウザでAPIをテストできる
echo "  Gateway:   ws://localhost:8080/ws"
# ↑ ゲートウェイ: WebSocket接続先（リアルタイム通信用）ポート8080
#   ws:// はWebSocketプロトコル（http://のリアルタイム版のようなもの）
echo ""
echo "Logs: docker compose logs -f"
# ↑ ログ表示コマンド: -f でリアルタイムにログを追跡（follow）
echo "Stop: docker compose down"
# ↑ 停止コマンド: 全コンテナを停止・削除
