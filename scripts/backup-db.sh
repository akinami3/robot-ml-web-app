#!/usr/bin/env bash
# =============================================================================
# DB Backup Script
# データベースバックアップスクリプト
# =============================================================================
#
# 【このスクリプトの目的】
# PostgreSQLデータベースの内容を定期的にバックアップ（保存）します。
# 万が一データが消えたり壊れたりしても、バックアップから復元できます。
#
# 【バックアップの重要性】
# データベースには以下のような重要データが入っています:
#   - ユーザーアカウント情報
#   - ロボットの設定データ
#   - 機械学習のモデル情報
#   - センサーデータの履歴
# これらが失われると復旧が非常に困難なので、定期バックアップは必須です。
#
# 【使い方】
#   ./scripts/backup-db.sh                          # 手動バックアップ
#   crontab に登録して定期実行するのが推奨
#   例: 0 3 * * * /path/to/scripts/backup-db.sh     # 毎日AM3時に実行
# =============================================================================

# シェルスクリプトの安全装置
set -euo pipefail

# スクリプトとプロジェクトのディレクトリを取得
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"

# -----------------------------------------------------------------------------
# バックアップ設定の変数定義
# -----------------------------------------------------------------------------
# ${BACKUP_DIR:-$PROJECT_DIR/backups} : 環境変数BACKUP_DIRが未設定ならデフォルトパスを使用
#   ${変数名:-デフォルト値} : Bashのパラメータ展開
#   環境変数を外部から上書きすることで、バックアップ先を変更できる
#   例: BACKUP_DIR=/mnt/nas/backups ./scripts/backup-db.sh
BACKUP_DIR="${BACKUP_DIR:-$PROJECT_DIR/backups}"

# date コマンドでタイムスタンプを生成
# +%Y%m%d_%H%M%S : フォーマット指定
#   %Y : 年（4桁） %m : 月（01-12） %d : 日（01-31）
#   %H : 時（00-23） %M : 分（00-59） %S : 秒（00-59）
#   例: 20260215_030000 （2026年2月15日 03:00:00）
# → バックアップファイル名に使うことで、いつのバックアップか分かるようにする
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# バックアップの保持期間（日数）
# ${BACKUP_RETENTION_DAYS:-30} : 環境変数で上書き可能、デフォルト30日
# 30日以上古いバックアップは自動削除される（ディスク容量の節約）
RETENTION_DAYS="${BACKUP_RETENTION_DAYS:-30}"

# -----------------------------------------------------------------------------
# .envファイルの読み込み
# -----------------------------------------------------------------------------
# source : 別ファイルの内容を現在のシェルで実行（変数を読み込む）
# 2>/dev/null : エラー出力を抑制（ファイルがなくてもエラーを表示しない）
# || true : sourceが失敗してもスクリプトを続行（set -eの影響を回避）
#   || : 左のコマンドが失敗した場合、右のコマンドを実行（OR演算子）
#   true : 常に成功する（終了コード0）コマンド
#
# 【この書き方の意味】
# .envファイルがあれば読み込む。なくても問題なし（デフォルト値を使う）。
source "$PROJECT_DIR/.env" 2>/dev/null || true

# バックアップディレクトリがなければ作成
mkdir -p "$BACKUP_DIR"

echo "=== Database Backup ==="
echo "Timestamp: $TIMESTAMP"

# =============================================================================
# pg_dump でデータベースのフルバックアップ
# =============================================================================
# 【pg_dump（ピージーダンプ）とは？】
# PostgreSQLのバックアップコマンド。データベースの内容をSQLファイルとして出力。
# このSQLファイルを使えば、データベースを完全に復元できる。
#
# BACKUP_FILE : バックアップファイルのパス
#   例: /home/user/project/backups/robot_ai_db_20260215_030000.sql.gz
#   .sql : SQL形式
#   .gz  : gzip圧縮（ファイルサイズを大幅に削減）
# =============================================================================
BACKUP_FILE="$BACKUP_DIR/robot_ai_db_${TIMESTAMP}.sql.gz"

# docker compose exec -T : コンテナ内でコマンド実行
#   -T : TTY（端末）を割り当てない（非対話的実行に必要。cronなどで使う場合）
#
# pg_dump の各オプション:
#   -U "${POSTGRES_USER:-robot_app}" : 接続ユーザー名（デフォルト: robot_app）
#   -d "${POSTGRES_DB:-robot_ai_db}" : データベース名（デフォルト: robot_ai_db）
#   --format=plain : 出力形式をプレーンテキスト（SQL文）にする
#     他の形式: custom（圧縮バイナリ）、directory（ディレクトリ）、tar
#   --no-owner : データベースオブジェクトの所有者情報を除外
#     → 別の環境（別のユーザー名）でも復元できるようにするため
#   --no-privileges : アクセス権限（GRANT/REVOKE）を除外
#     → 復元先の環境に合わせた権限設定ができるようにするため
#
# | gzip > "$BACKUP_FILE" : パイプとリダイレクト
#   | (パイプ) : pg_dumpの出力をgzipの入力に渡す
#   gzip : データを圧縮するコマンド（通常50-80%サイズ削減）
#   > : gzipの出力をファイルに書き込む
docker compose exec -T postgres pg_dump \
    -U "${POSTGRES_USER:-robot_app}" \
    -d "${POSTGRES_DB:-robot_ai_db}" \
    --format=plain \
    --no-owner \
    --no-privileges | gzip > "$BACKUP_FILE"

# du -h : ファイルサイズを人間が読みやすい形式で表示（Human-readable）
#   例: 4.0K, 1.2M, 3.5G
# cut -f1 : タブ区切りの1番目のフィールド（サイズ部分）だけを取り出す
echo "✓ Backup created: $BACKUP_FILE ($(du -h "$BACKUP_FILE" | cut -f1))"

# =============================================================================
# 古いバックアップの自動削除（ローテーション）
# =============================================================================
# 【バックアップローテーションとは？】
# 古いバックアップを自動的に削除して、ディスク容量を節約する仕組み。
# 例: 30日分だけ保持し、それより古いものは削除
#
# find コマンドの解説:
#   find "$BACKUP_DIR" : 検索対象のディレクトリ
#   -name "robot_ai_db_*.sql.gz" : ファイル名のパターンマッチ
#     * (ワイルドカード) : 任意の文字列にマッチ
#   -mtime "+$RETENTION_DAYS" : 最終更新日がN日より前のファイル
#     -mtime +30 : 30日以上前に更新されたファイル
#     -mtime -30 : 30日以内に更新されたファイル
#     -mtime  30 : ちょうど30日前に更新されたファイル
#   -delete : マッチしたファイルを削除
#
# 【findコマンドについて】
# Linux/Unixの強力なファイル検索コマンド。
# 名前、サイズ、日付、権限など様々な条件でファイルを検索できる。
# =============================================================================
echo "Cleaning up backups older than $RETENTION_DAYS days..."
find "$BACKUP_DIR" -name "robot_ai_db_*.sql.gz" -mtime "+$RETENTION_DAYS" -delete
echo "✓ Cleanup complete"

# 現在のバックアップ一覧を表示
# ls -lh : ファイルの詳細情報を人間が読みやすい形式で表示
#   -l : 詳細表示（権限、サイズ、日時など）
#   -h : サイズを人間が読みやすい形式で表示
# 2>/dev/null : エラー（ファイルが見つからない場合）を抑制
# || echo "  (none)" : lsが失敗した場合（バックアップがない場合）に代替メッセージ
echo ""
echo "Current backups:"
ls -lh "$BACKUP_DIR"/robot_ai_db_*.sql.gz 2>/dev/null || echo "  (none)"
